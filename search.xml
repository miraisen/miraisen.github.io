<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>LeetCode贪心篇</title>
      <link href="/2024/08/25/LeetCode%E8%B4%AA%E5%BF%83%E7%AF%87/"/>
      <url>/2024/08/25/LeetCode%E8%B4%AA%E5%BF%83%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<p>贪心算法 &#x2F; 贪心思想：保证每次操作都是局部最优的，使最后得到的结果是全局最优的。</p><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithms </tag>
            
            <tag> Greedy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前后端分离项目部署</title>
      <link href="/2024/08/23/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/"/>
      <url>/2024/08/23/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>后端：IDEA maven</p><p>前端：node、vue环境</p><p>数据库：mysql</p><span id="more"></span><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>1、获取代码到相应目录</p><p>2、后端代码处理</p><ul><li>jdk版本</li><li>maven配置（路径配置是否生效）</li><li>执行数据库脚本、修改数据库连接配置 localhost 改为 自己主机的ip</li></ul><blockquote><p>所以写数据库的时候要将脚本记录下来，比如建立一个sql文件夹下放置table.txt</p></blockquote><ul><li>启动服务验证</li></ul><blockquote><p>pom.xml文件右键 —— add as maven project</p></blockquote><p>3、前端代码处理</p><ul><li>加载依赖 （终端中输入npm -i）</li><li>配置执行环境</li><li>启动验证</li></ul>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode数与位篇</title>
      <link href="/2024/07/26/LeetCode%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AF%87/"/>
      <url>/2024/07/26/LeetCode%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AF%87/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode位运算篇</title>
      <link href="/2024/07/26/LeetCode%E6%95%B0%E4%B8%8E%E4%BD%8D%E7%AF%87/"/>
      <url>/2024/07/26/LeetCode%E6%95%B0%E4%B8%8E%E4%BD%8D%E7%AF%87/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode哈希表篇</title>
      <link href="/2024/07/22/LeetCode%E5%93%88%E5%B8%8C%E8%A1%A8%E7%AF%87/"/>
      <url>/2024/07/22/LeetCode%E5%93%88%E5%B8%8C%E8%A1%A8%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<p>用哈希集合存储元素，可以在O(1)的时间内判断一个元素是否在集合中，从而降低时间复杂度。</p><span id="more"></span><p>创建哈希表:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Integer&gt; set1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;();</span><br></pre></td></tr></table></figure><p>加入元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : nums1)&#123;</span><br><span class="line">set1.add(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建二元哈希表函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;Integer, Integer&gt; <span class="title function_">countNums</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; counts = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!counts.containsKey(num))&#123;</span><br><span class="line">                counts.put(num, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                counts.put(num, counts.get(num) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> counts;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>entrySet()</strong></p><p>​返回hashMap中所有映射项的集合视图</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : counts.entrySet())&#123;</span><br><span class="line">    entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode递归篇</title>
      <link href="/2024/07/14/LeetCode%E9%80%92%E5%BD%92%E7%AF%87/"/>
      <url>/2024/07/14/LeetCode%E9%80%92%E5%BD%92%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h2 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300. 最长递增子序列"></a>300. 最长递增子序列</h2><p>复杂度最低的方法： 二分 + 贪心</p><span id="more"></span><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    public <span class="built_in">int</span> lengthOfLIS(<span class="built_in">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">List</span>&lt;Integer&gt; g = new ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> x : nums)&#123;</span><br><span class="line">            <span class="built_in">int</span> j = lowerBound(g, x);</span><br><span class="line">            <span class="keyword">if</span>(j == g.size())&#123;</span><br><span class="line">                g.add(x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                g.<span class="built_in">set</span>(j, x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> g.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private <span class="built_in">int</span> lowerBound(<span class="type">List</span>&lt;Integer&gt;g, <span class="built_in">int</span> target)&#123;</span><br><span class="line">        <span class="built_in">int</span> left = -<span class="number">1</span>, right = g.size(); // 开区间</span><br><span class="line">        <span class="keyword">while</span> (left + <span class="number">1</span> &lt; right)&#123;</span><br><span class="line">            <span class="built_in">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (g.get(mid) &lt; target)&#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化列表，g用于存储当前找到的最长递增子序列。不一定是实际的子序列，但长度是对的。</p><p>对数组nums中的每个元素 x 进行遍历，使用lowerBound方法找到x在g中的位置j。</p><p>如果j等于g的长度，说明x可以扩展当前的序列，把它添加到g的末尾；否则用x替换g中位置j的元素，以维持g的递增性质。</p><p>返回g的长度，这就是最长递增子序列的长度。</p><p>二分查找方法lowerBound用于找到第一个不小于target的元素位置。</p><p>Java中g.set(i, j)方法用于将g中下标为i的元素替换为j</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode栈与队列篇</title>
      <link href="/2024/07/05/LeetCode%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E7%AF%87/"/>
      <url>/2024/07/05/LeetCode%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h3 id="03-01-三合一"><a href="#03-01-三合一" class="headerlink" title="03.01.三合一"></a>03.01.三合一</h3><p>用一个数组实现三个栈。</p><p>分析：</p><p>可以通过将数组的前三分之一分配到第一个栈，第二个三分之一分配到第二个栈，最后的第三个三分之一分配到第三个栈。来模拟数组中的三个栈。实际上某个栈可能比其他的更大，这种平均的分法就不可行了。如果考虑灵活划分，可以移动栈，要保证使用所有可用的容量，把数组看作是循环的。</p><p>也可以直接用二维数组来存三个栈。二维数组的每一行代表一个栈，同时使用一个locations记录每个栈待插入的下标。</p><span id="more"></span><h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><p>以739.每日温度为例，需要求解的是对于第i天，下一个更高的温度出现在几天后。</p><p>对于温度数组t[i] :  [1,4,3,5,5,2,3,6]。可以从后往前遍历：</p><blockquote><p>[6]</p><p>[6,3]</p><p>[6,3,2]</p><p>[6,5]        5比2大，弹出2，5比3大，弹出3，5小于6，不再弹出</p><p>[6,5] 相同的仍然弹出</p><p>[6,5,3]</p><p>[6,5,4]</p><p>[6,5,4,1]</p></blockquote><p>总结规律：</p><p>​记录的数据加在最上面，丢掉数据也从最上面开始 —— 后进先出</p><p>​单调性：记录t[i]之前会把所有&lt;&#x3D;t[i]的数据丢掉，不可能出现上面大下面小</p><p>——单调栈</p><p>栈顶: st[-1]</p><p>把所有小于目标数的元素出栈：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> st <span class="keyword">and</span> t &gt;= temperatures[st[-<span class="number">1</span>]]:</span><br><span class="line">st.pop()</span><br></pre></td></tr></table></figure><p>注意这里栈保存的是温度对应的下标。</p><p>出栈后如果栈为空，说明t&gt;&#x3D;右边数（即气温在这之后都不会升高，初始化完成即可）；如果栈不为空，说明答案为 st[-1] - i （栈顶的数的下标减去i），再将这个元素的下标存到栈顶。</p><p>复杂度分析：每个元素最多入栈一次，出栈一次，所以总的循环次数是O(n)。由于栈中不存在相同元素，本题的空间复杂度是O(min(n, U))，U就是数组的最大值减去数组的最小值再加1。</p><p><em>及时去掉无用数据，保证栈中数据有序</em></p><p>如果从左到右遍历：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, t <span class="keyword">in</span> <span class="built_in">enumerate</span>(temperatures):</span><br><span class="line">    <span class="keyword">while</span> st <span class="keyword">and</span> t &gt; temperatures[st[-<span class="number">1</span>]]:</span><br><span class="line">        j = st.pop()</span><br><span class="line">        ans[j] = i - j</span><br><span class="line">    st.append(i)</span><br></pre></td></tr></table></figure><p>从左到右遍历的做法更能体现单调栈的特点，一旦t小于等于栈顶，意味着t同时小于等于栈里的任何数。所以t无法更新栈顶，也无法更新栈里任何元素的答案。</p><p>练习题: 496.下一个更大元素 I</p><p>核心就是单调栈：从右到左遍历，如果大于栈顶元素就出栈，统一入栈。</p><p>技巧：建立{元素值:下标} <code>idx = &#123;x:i for i, x in enumerate(nums1)&#125;</code></p><h2 id="求前k个高频元素"><a href="#求前k个高频元素" class="headerlink" title="求前k个高频元素"></a>求前k个高频元素</h2><p>1、统计元素出现频率（使用map进行统计）</p><p>2、对频率排序（使用一种容器适配器——优先级队列）</p><p>3、找出前k个高频元素</p><h4 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h4><p>​“披着队列外衣”的堆，因为优先级队列对外接口只是从队头取元素，从队尾添加元素，可以看成是队列。</p><p>并且优先级队列<strong>内部元素自动依照元素的权值排列</strong>。</p><p>默认情况下priority_queue利用max-heap即大顶堆完成对元素的排序，这个大顶堆是以vector为表现形式的<strong>完全二叉树</strong>。</p><blockquote><p>堆是一棵完全二叉树，树中每个结点的值都不小于（或不大于）其左右孩子的值。如果父结点是大于等于左右子节点，就是max-heap；否则为小顶堆。</p><p>所以用大顶堆和小顶堆可以直接用优先级队列，底层实现都是一样的，从小到大排就是小顶堆，从大到小排就是大顶堆。</p></blockquote><p><em>为什么不用快排，使用快排要将map转换为vector的结构，然后对整个数组进行排序，这种场景下，其实只需要k个有序的序列，所以用优先级队列是最优的</em>。</p><p>要统计最大前k个元素，只有小顶堆每次将最小的元素弹出，最后小顶堆里积累的才是前k个最大元素。</p><p>步骤为：1、根据出现频率构建map</p><p>2、构建小顶堆，将所有频率加入到堆中，如果堆的大小大于k，就将元素从堆顶弹出</p><p>3、倒叙构建数组</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode动态规划篇</title>
      <link href="/2024/07/04/LeetCode%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AF%87/"/>
      <url>/2024/07/04/LeetCode%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<p>416.分割等和子集</p><p>给你一个 只包含正整数 的 非空数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><p>一开始试图用排序加前缀和判断，但在两个子集相同的情况这种判断不适用。比如 1 2 1 2，是可以分割成两个子集的，但排序后只能分成 1 1 和 2 2。</p><span id="more"></span><p>学习题解：</p><p>设nums的元素和是s。要满足两个子集的元素和相等，必须满足：</p><p>1、s是偶数 2、子集元素和恰好等于s&#x2F;2。</p><p>所以，首先判断s如果是奇数，直接返回。如果s是偶数，问题转变为了能否从nums中选出一个子序列，其元素和恰好为s&#x2F;2。</p><p>那么这实际上就是0-1背包问题。</p><p>0-1背包的子问题：在剩余容量为c时，从前i个物品中得到的最大价值和。</p><p>dfs(i,c) &#x3D; max(dfs(i-1), c), dfs(i-1, c-w[i])+v[i])</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">zero_one_knapsack</span>(<span class="params">capacity: <span class="built_in">int</span>, w: <span class="type">List</span>[<span class="built_in">int</span>], v:<span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    n = <span class="built_in">len</span>(w)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#记忆化搜索加装饰器</span></span><br><span class="line"><span class="meta">    @cache</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i, c</span>):</span><br><span class="line">        <span class="comment"># 先判断边界条件</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="number">0</span>: <span class="comment"># 此时一个物品都没有了</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> c &lt; w[i]: <span class="comment"># 可选的物品容量大于剩余容量，不予考虑</span></span><br><span class="line">            <span class="keyword">return</span> dfs(i-<span class="number">1</span>, c)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dfs(i-<span class="number">1</span>, c), dfs(i-<span class="number">1</span>, c-w[i]) + v[i]) <span class="comment"># 否则纳入考虑，选出价值最大的方案</span></span><br><span class="line">    <span class="keyword">return</span> dfs(n-<span class="number">1</span>, capacity) <span class="comment"># 从最后一个物品开始选，剩余容量就是初始容量</span></span><br></pre></td></tr></table></figure><p>0-1背包的常见变形：</p><ul><li>至多装capacity，求方案数&#x2F;最大价值和</li><li>恰好装capacity，求方案数&#x2F;最大&#x2F;最小价值和</li><li>至少装capacity，求方案数&#x2F;最小价值和</li></ul><p>记忆化搜索的复杂度：状态个数 * 单个状态的计算时间。</p><p>记忆化搜索：定义dfs(i,j)表示能否从nums[0]到nums[i]中选出一个和为j的子序列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">canPartition</span>(<span class="params">self, nums:<span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line"><span class="meta">        @cache</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i: <span class="built_in">int</span>, j: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> j == <span class="number">0</span></span><br><span class="line">            <span class="keyword">return</span> j &gt;= nums[i] <span class="keyword">and</span> dfs(i-<span class="number">1</span>, j- nums[i]) <span class="keyword">or</span> dfs(i-<span class="number">1</span>, j)</span><br><span class="line">       </span><br><span class="line">        s = <span class="built_in">sum</span>(nums)</span><br><span class="line">        <span class="keyword">return</span> s % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">and</span> dfs(<span class="built_in">len</span>(nums)-<span class="number">1</span> , s//<span class="number">2</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode链表篇</title>
      <link href="/2024/06/30/LeetCode%E9%93%BE%E8%A1%A8%E7%AF%87/"/>
      <url>/2024/06/30/LeetCode%E9%93%BE%E8%A1%A8%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h2 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160.相交链表"></a>160.相交链表</h2><p>要找出并返回两个单链表相交的起始节点。</p><p><img src="/LeetCode%E9%93%BE%E8%A1%A8%E7%AF%87/160_statement.png" alt="img"></p><p>a2和b3可能值相等，但节点在内存中指向的是不同的位置，因此仍然是不同的节点。</p><span id="more"></span><p>读题后思路是用双指针一个一个比较，但具体比较的应该是内存中存储的是同一个位置的第一个节点即为答案。根据链表结构，node.next指的是下一个节点的指针。故比较这个值是否相等即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        h1 = headA</span><br><span class="line">        h2 = headB</span><br><span class="line">        <span class="keyword">while</span>(h1):</span><br><span class="line">            <span class="keyword">while</span>(h2):</span><br><span class="line">                <span class="keyword">if</span> h1 == h2:</span><br><span class="line">                    <span class="keyword">return</span> h1</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    h2 = h2.<span class="built_in">next</span></span><br><span class="line">            h1 = h1.<span class="built_in">next</span></span><br><span class="line">            h2 = headB</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>超时了，学习题解：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        h1 = headA</span><br><span class="line">        h2 = headB</span><br><span class="line">        <span class="keyword">while</span> h1 != h2:</span><br><span class="line">            h1 = h1.<span class="built_in">next</span> <span class="keyword">if</span> h1 <span class="keyword">else</span> headB</span><br><span class="line">            h2 = h2.<span class="built_in">next</span> <span class="keyword">if</span> h2 <span class="keyword">else</span> headA</span><br><span class="line">        <span class="keyword">return</span> h1</span><br></pre></td></tr></table></figure><p>思路是: </p><p><img src="/LeetCode%E9%93%BE%E8%A1%A8%E7%AF%87/1615224578-EBRtwv-Picture1.png" alt="Picture1.png"></p><p>A先遍历完链表headA，再开始遍历链表headB，当走到node时，共走步数a+b-c，同理，B走到公共节点时共走步数b+a-c。</p><p>如果有公共尾部，c&gt;0；如果没有公共尾部，c&#x3D;0。A和B同时指向null</p><h2 id="237-删除链表中的节点"><a href="#237-删除链表中的节点" class="headerlink" title="237.删除链表中的节点"></a>237.删除链表中的节点</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node.val = node.<span class="built_in">next</span>.val</span><br><span class="line">node.<span class="built_in">next</span> = node.<span class="built_in">next</span>.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p>如果头节点可能被删除或修改，加个dummy会很方便</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dummy = ListNode(<span class="built_in">next</span> = head)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Note_for_cs50x</title>
      <link href="/2024/06/29/Note-for-cs50x/"/>
      <url>/2024/06/29/Note-for-cs50x/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><ul><li>problem-solving</li><li>for most beginner</li><li>computational thinking, abstraction, algorithms, data structures</li><li>program fundamentally and new language</li></ul><p>The recommended workflow: watch lecture -&gt; watch section -&gt; watch shorts -&gt; submit problem set</p><span id="more"></span><h1 id="Week-0"><a href="#Week-0" class="headerlink" title="Week 0"></a>Week 0</h1><p>30min</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++笔记</title>
      <link href="/2024/05/17/C++%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/05/17/C++%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>本文为在C++使用过程中的盲区与疑问记录，因为没有系统地学习过C++所以将会记录较多的基础知识。受时间限制，目前只能一点点积累基础，系统学习对时间demanding并且不面向应用，不能很好掌握。</p><span id="more"></span><p>[TOC]</p><h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><p>C++标准模板库(Standard Template Library, STL) 是一套功能强大的</p><h1 id="vector容器"><a href="#vector容器" class="headerlink" title="vector容器"></a>vector容器</h1><p>向量是一个封装了动态大小数组的顺序容器(Sequence Container)。跟任意其他类型容器一样，它能够存放各种类型的对象。可以简单认为向量是一个能够存放任意类型的<strong>动态数组</strong>。</p><p>特性：顺序序列（线性顺序）、动态数组（支持对任意元素进行快速直接访问）、能够感知内存分配器的（Allocator-aware）（使用一个内存分配器对象来动态处理它的存储需求）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>(); <span class="comment">//空</span></span><br><span class="line"><span class="built_in">vector</span>(<span class="type">int</span> nSize); <span class="comment">// 元素个数为nSzie</span></span><br><span class="line"><span class="built_in">vector</span>(<span class="type">int</span> nSize, <span class="type">const</span> t&amp; t); <span class="comment">// 值均为t</span></span><br><span class="line"><span class="built_in">vector</span>(<span class="type">const</span> vector&amp;); <span class="comment">// 复制构造函数</span></span><br><span class="line"><span class="built_in">vector</span>(begin, end); <span class="comment">//复制[begin, end)区间内另一个数组的元素到vector中</span></span><br></pre></td></tr></table></figure><p>需要 #include &lt; vector&gt;</p><p>比如 <code>vector&lt;pair&lt;int, int&gt;&gt; jobs(n)</code>; 再通过遍历赋值，<code>jobs[i] = &#123;d[i], p[i]&#125;</code> 就可以实现等同于python中的zip()操作。</p><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="ranges-sort"><a href="#ranges-sort" class="headerlink" title="ranges::sort"></a>ranges::sort</h2><p>C++20引入的新特性。</p><p><code>std::ranges::sort(numbers);</code>就可以完成排序。</p><h1 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h1>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web开发实践</title>
      <link href="/2024/05/12/Web%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/"/>
      <url>/2024/05/12/Web%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>开发Web页面过程的学习记录。</p><span id="more"></span><h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><p><img src="/Web%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/02A7DD95-22B4-4FB9-B994-DDB5393F7F03.jpg" alt="img"></p><p>只有<body>区域才会在浏览器中显示。</body></p><html lang="en"> 表示HTML文档的根元素，用于指定文档的语言为英语。<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p>&#x2F; </p><p> 定义段落</p><p><a> 定义链接</a></p><p><img> 定义图像</p><tr>标签定义表格中的行<meta> 提供HTML文档的元数据，元数据不显示在客户端，但是会被浏览器解析。通常用于指定网页的描述，关键词，文件的最后修改时间等。<p>width&#x3D;device-width：指定视口宽度与设备宽度相同，适配不同设备的屏幕宽度。</p><p>initial-scale&#x3D;1.0：初始缩放比例为1.0，确保页面以正常比例显示。</p><p>maximum-scale&#x3D;1.0,minimum-scale&#x3D;1.0：限制缩放比例的最大和最小值，都设置为1.0，即禁止用户进行缩放。</p><p>user-scalable&#x3D;no：禁止用户手动缩放页面，保持固定的缩放比例。</p><p>viewport-fit&#x3D;cover：指定视口填充整个屏幕，确保内容在各种设备上都能完全显示。</p><p>HTML文档模板</p><p>​设置字符编码、标题、引入样式表和脚本等。</p><p>​DOCTYPE声明、html元素、head元素、body元素</p><p>​</p><h3 id="框架设置"><a href="#框架设置" class="headerlink" title="框架设置"></a>框架设置</h3><p>frameset framespacing&#x3D;”0” border&#x3D;”0” rows&#x3D;”0” frameborder&#x3D;”0”：设置框架的间距、边框、行等参数。</p><frame name="main" src="./html/login.html" scrolling="auto" noresize>：定义一个框架，指定了其名称为"main"，加载内容的来源为"./html/login.html"，允许自动滚动，且不可调整大小。<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line"><span class="selector-attr">[v-cloak]</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>使用属性选择器[v-cloak]，设置其display属性为none。这通常用于在页面加载时隐藏具有 v-cloak 属性的元素，直到Vue.js实例加载并准备好显示这些元素。</p><h1 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h1><p>XML指可扩展标记语言（Extensible Markup Language）。XML用来传输和存储数据，HTML则用来表现数据。</p><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>提供避免元素命名冲突的方法。</p><p>在XML中，元素名称是由开发者定义的，当两个文档使用相同的元素名时，就会发生命名冲突。</p><p>在XML中的命名冲突可以通过使用名称前缀来避免。例如<code>&lt;h:table&gt;</code>和<code>&lt;f:table&gt;</code>。</p><h3 id="xmlns属性"><a href="#xmlns属性" class="headerlink" title="xmlns属性"></a>xmlns属性</h3><p>当在XML中使用前缀时，一个所谓的用于前缀的命名空间必须被定义。命名空间是在元素的开始标签的xmlns属性中定义的。例如&lt;h:table xmlns:h&#x3D;”<a href="http://www.w3.org/TR/html4/%22%3E">http://www.w3.org/TR/html4/&quot;&gt;</a></p><h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="获取日期"><a href="#获取日期" class="headerlink" title="获取日期"></a>获取日期</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个 Date 对象，表示当前日期和时间</span></span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前日期的四位数年份</span></span><br><span class="line"><span class="keyword">var</span> year = date.<span class="title function_">getFullYear</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出年份</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(year); <span class="comment">// 例如：2024</span></span><br></pre></td></tr></table></figure><h1 id="项目解读"><a href="#项目解读" class="headerlink" title="项目解读"></a>项目解读</h1><h2 id="project-config-js"><a href="#project-config-js" class="headerlink" title="project_config.js"></a>project_config.js</h2><blockquote><p>从本地存储获取project_pid(项目ID), project_uid(用户ID)，project_data</p><p>构建项目令牌</p><p>定义服务器URL</p><p>定义登录URL</p><p>定义配置传感器动态监控的URL，用于与服务器通信</p><p>还有一些模块的URL定义</p><p>Json数据转Excel</p><p>​通过解析JSON字符串，赋值给arrData</p><p>​创建包含HTML表格起始标签’<table>‘的字符串变量excel</table></p><p>​将JSONData数组的第一个对象的键生成一个表格行（表头设置）</p><p>遍历arrData数组中的每一个对象，将每个对象的属性值作为表格行内容添加到excel变量中</p><p>创建包含HTML文档开头的字符串变量excelFile，HTML文档包含特定的命名空间声明</p><p>为生成的 HTML 文件添加 Excel 特定的 XML 标记，以确保文件在 Excel 中打开时能正确显示工作表名称、网格线等设置</p><p>将生成的 excelFile 字符串转换为一个数据 URI，以便在浏览器中作为下载链接使用。这种方式允许用户点击链接并下载生成的 Excel 文件</p><p>&lt;以上操作是为了生成Excel数据并提供下载链接&gt;</p><p>定义一个函数，用于检测当前环境是否为移动设备</p><p>定义一个函数，实现深拷贝一个JSON对象</p><p>定义一个函数，实现将日期转换为字符串格式</p><p>定义一个函数，根据传入的参数动态配置用户界面，设置特定页面的背景图像、背景颜色以及加载特效脚本。</p></blockquote><p>localStorage.getItem()：从本地存储中获取之前存储的值，可以用于在页面加载时初始化应用程序的状态，或者在用户进行操作时检索和使用这些值。</p><p>console.log(): 在控制台输出信息，接受一个参数，该参数可以是数组，对象或任何消息</p><p>**PHP(Hypertext Preprocessor)**文件是一种服务器端脚本文件，用于在Web服务器上执行服务器端代码。可以与服务器进行交互、执行各种任务，如处理表单数据、访问数据库、生成动态网页内容。</p><p>URL地址提供了与服务器进行通信的接口，通过发送HTTP请求到这些URL，可以实现相应模块的功能操作。</p><p>JSON.parse(): JavaScript中的一个内置函数，用于将JSON字符串解析为对应的JavaScript对象。当从服务器或其他来源获取到 JSON 格式的数据时，它通常是一个字符串。为了在 JavaScript 中使用这些数据，需要将它们转换为 JavaScript 对象。</p><p>Object.keys() 获取对象所有属性名</p><p><code>xmlns:o=&#39;urn:schemas-microsoft-com:office:office&#39;</code>: 为 <code>o</code> 前缀声明一个 XML 命名空间，通常与 Microsoft Office 相关</p><p><code>xmlns:x=&#39;urn:schemas-microsoft-com:office:excel&#39;</code>: 为 <code>x</code> 前缀声明一个 XML 命名空间，通常与 Microsoft Excel 相关</p><p><code>xmlns=&#39;http://www.w3.org/TR/REC-html40&#39;</code>: 为默认命名空间声明一个 XML 命名空间，指定 HTML 4.0 规范的 URI</p><p>嵌入的 XML 标签和条件注释使得生成的 HTML 文件在 Microsoft Excel 中打开时，可以正确识别和应用这些设置，从而使数据按照预期显示和格式化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> uri = <span class="string">&#x27;data:application/vnd.ms-excel;charset=utf-8,&#x27;</span> + <span class="built_in">encodeURIComponent</span>(excelFile);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> link = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    link.<span class="property">href</span> = uri;</span><br><span class="line"></span><br><span class="line">    link.<span class="property">style</span> = <span class="string">&quot;visibility:hidden&quot;</span>;</span><br><span class="line">    link.<span class="property">download</span> = <span class="title class_">FileName</span> + <span class="string">&quot;.xls&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(link);</span><br><span class="line">    link.<span class="title function_">click</span>();</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">removeChild</span>(link);</span><br></pre></td></tr></table></figure><p>将生成的’excelFile’字符串编码为数据URL，并创建一个下载链接，使用户可以点击下载生成的Excel文件，通过添加隐藏的链接并触发点击事件，自动完成文件下载。</p><h3 id="function-config-UI-name"><a href="#function-config-UI-name" class="headerlink" title="function config_UI(name)"></a>function config_UI(name)</h3><p>首先解析JSON数据，将JSON字符串解析为JavaScript对象，检查是否为空。</p><p>处理sensor_monitor页面: 加载特效脚本、设置背景图像、设置背景颜色</p><p>处理user_manage页面：加载特效脚本、设置背景图像、设置背景颜色</p><p>处理default页面：加载特效脚本、设置背景图像、设置背景颜色</p><p>处理main页面：设置背景图像、设置背景颜色</p><h2 id="index-html"><a href="#index-html" class="headerlink" title="index.html"></a>index.html</h2><p>配置和实现一个根据设备类型（移动设备或桌面设备）自动跳转到相应登录页面的功能。它使用了 jQuery 来发送 AJAX 请求，并根据服务器返回的数据决定跳转逻辑。这种机制在需要根据不同设备提供不同登录页面的场景下非常有用。</p><blockquote><p>DOCTYPE声明，声明文档类型为HTML5</p><p>定义html元素； ‘lang’属性指定文档的语言为英语</p><p>为了配合Vue.js的使用，添加一个简单的CSS样式，可以隐藏带有’v-cloak’属性的元素</p><p>定义基本的meta标签，包括字符编码和视口设置。字符编码指定为UTF-8、设置视口元数据，确保网页在移动设备上能以合理的比例显示，而不会自动缩放。</p><p>引入project_config.js文件，引入jquery-3.4.1.min.js文件，这是jQuery库的一个压缩版本。（jQuery是一个快速、简洁的JavaScript库，简化了HTML文档遍历、事件处理、动画和Ajax交互)</p><p>编写内联javascript代码：</p><p>创建db_request_option函数，用于发送AJAX请求，根据请求类型（POST或GET）向服务器发送数据并处理服务器的响应。</p><p>将project_data字符串解析成JavaScript对象config_data，检查是否有效（不为null且不为空字符串）</p><p>检查路由配置，即检查config_data中的sys_cfg_router_enable是否存在且不为空</p><p>发送AJAX请求：调用db_request_option函数发送一个GET请求，从router表中选择数据</p><p>遍历返回的数据，根据type和enable字段设置pc_login_url和app_login_url</p><p>判断设备类型，根据设备类型和对应的URL进行页面跳转，如果对应的URL不存在，跳转到默认的login.html</p><p>如果路由配置未启用或sys_cfg_router_enable不存在，直接跳转到login.html</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-attr">[v-cloak]</span> &#123;</span></span><br><span class="line"><span class="language-css"><span class="attribute">display</span>: none;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在Vue.js完全编译和渲染之前，带有’v-cloak’属性的元素会被隐藏。一旦Vue.js完全加载并挂载到’#app’元素，’v-cloak’属性会被移除，模板内容会显示出来。这种方法可以避免在Vue.js加载时出现的闪烁问题，确保用户在看到页面内容之前已经完全加载和渲染。</p><head>部分的主要功能是提供文档的元数据和链接资源，这些内容对网页的呈现和行为有重要影响。通过适当地使用这些标签，可以确保网页在不同的设备上正确显示，并优化搜索引擎的表现。<p>在HTML文档的’<head>‘部分或’</head><body>‘部分中添加’<script>'标签可以引入外部JavaScript文件。这些脚本文件通常包含功能代码、库或者配置，用于增强网页的交互性和动态性。</p><p>如果脚本在页面加载之前就需要执行（如页面初始化配置），可以将其放在'<head>'部分，例如某些配置文件或必须先加载的库文件。</p><p>如果脚本在页面加载之后执行（如页面交互逻辑），最好放在<body>底部，这样可以确保页面元素已经加载完毕。大多数jQuery代码通常放在页面底部，以确保DOM元素已经完全加载。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 这里可以编写内联的 JavaScript 代码</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>db_request_option</strong></p><p>参数：type（请求类型） table（数据库表名） option（操作选项） arg_data（请求的数据） callback（请求成功后的回调函数，用于处理返回的数据）</p><p>如果请求的数据不为空，就进行深拷贝以避免修改原始数据。</p><p>根据请求类型构建请求URL，对于post请求，将数据作为请求体发送，对于get请求，将数据作为查询字符串参数发送。</p><p>使用jQuery的'$.ajax'方法发送AJAX请求，指定请求类型、数据类型、URL以及成功后的处理函数。</p><p>在'success'回调函数中，尝试解析返回的数据为JSON，如果解析失败，则直接使用返回的数据。</p><p>调用回调函数'callback'处理解析后的数据</p><hr><p>可以使用JSON.parse(JSON.stringify(object))进行深拷贝</p><p>JSON.parse用于解析JSON字符串，但在AJAX请求返回的数据已经是对象时，不需要再解析，因此需要try-catch处理</p><p>URL构建：服务器端点　查询参数　数据对象　数据库表名</p><h1 id="问题及建议记录"><a href="#问题及建议记录" class="headerlink" title="问题及建议记录"></a>问题及建议记录</h1><p>1、使用document.write</p><p>在文档加载完毕后调用会重写整个页面，通常建议使用动态加载脚本的方法，例如创建<script>元素并追加到DOM中</p><p>２、生成URL时data部分可能包含特殊字符，这些字符在URL中需要被编码</p><p>可以用encodeURIComponent函数对JSON.stringify(data)的结果进行编码</p><p>3、将大量数据放在URL中可能会有长度限制，并且暴露在URL中的数据可能会带来安全问题。</p><p>通常推荐使用POST请求来传递大量或敏感数据</p></script></body></p></head></tr></html>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
            <tag> css </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode树篇</title>
      <link href="/2024/05/09/LeetCode%E6%A0%91%E7%AF%87/"/>
      <url>/2024/05/09/LeetCode%E6%A0%91%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><p>层序遍历是二叉树中很重要的一个问题。</p><p>BFS要借助队列来完成，先把根元素加入队列。对队列进行非空循环，对节点的左右子节点进行判断，如果存在就加入队列。每次循环将出队的元素作为新的根节点。</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">cenciTraverseWithQueue</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(); <span class="comment">// 创建队列</span></span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll(); <span class="comment">// 元素出队即打印</span></span><br><span class="line">        System.out.println(node.val); <span class="comment">// 打印出队的元素</span></span><br><span class="line">        <span class="keyword">if</span> (root.leftNode != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue.offer(node.leftNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.rightNode != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue.offer(node.rightNode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>借助两个数组完成：</p><p>   cur：保存当前层的节点</p><p>   next：保存下一层的节点</p><p>遍历cur中所有的节点，将节点的子节点加入next中。遍历完后将cur替换成next数组。循环退出的条件是cur为空。</p><p>Java:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//空数组</span></span><br><span class="line">List.of()</span><br><span class="line"><span class="comment">//判断数组是否为空</span></span><br><span class="line">cur.isEmpty()</span><br><span class="line"><span class="comment">//创建数组时预分配空间</span></span><br><span class="line">List&lt;Integer&gt; vals = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(cur.size());</span><br><span class="line"><span class="comment">//遍历数组</span></span><br><span class="line"><span class="keyword">for</span> (TreeNode node : cur)&#123;&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>八股总结</title>
      <link href="/2024/05/07/%E5%85%AB%E8%82%A1%E6%80%BB%E7%BB%93/"/>
      <url>/2024/05/07/%E5%85%AB%E8%82%A1%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><span id="more"></span><h1 id="腾讯测试与质量管理实习-24-4-2"><a href="#腾讯测试与质量管理实习-24-4-2" class="headerlink" title="腾讯测试与质量管理实习 24&#x2F;4&#x2F;2"></a>腾讯测试与质量管理实习 24&#x2F;4&#x2F;2</h1><p>1、自我介绍</p><p>2、讲讲电子设计大赛中做了些什么</p><p>3、讲讲专业课大概学了些什么</p><p>4、堆和栈的区别，为什么要分堆和栈</p><p>5、TCP和UDP的区别以及应用场景</p><p>6、三次握手流程</p><p>7、Python装饰器</p><p>8、有进行过Python的网络开发吗</p><p>9、Http和Https的区别</p><p>10、拥塞控制的原理</p><p>11、Linux的常用命令</p><p>12、手撕：最长无重复子串</p><h1 id="华为无线通用软开实习-24-5-9"><a href="#华为无线通用软开实习-24-5-9" class="headerlink" title="华为无线通用软开实习 24&#x2F;5&#x2F;9"></a>华为无线通用软开实习 24&#x2F;5&#x2F;9</h1><p>1、自我介绍</p><p>2、对专业的感受，主要是学什么</p><p>我答的物联网相关</p><p>3、展开问项目，项目中担当什么角色，做了哪些事情，有什么感受</p><p>4、堆区和栈区的区别，为什么要分堆和栈</p><p>5、项目中有没有做过内存管理，怎么做的</p><p>6、函数指针和指针函数的区别，应用场景</p><p>7、（挖简历）电子设计竞赛的题目和做了什么工作，奖学金是哪一年拿的</p><p>8、为什么要进行编码，常用的编码有哪些，原理分别是什么</p><p>9、FPGA、单片机、DSP的区别</p><p>10、（通信相关）4G和5G的区别，技术有哪些，技术原理</p><p>11、手撕（三道题抽一道）</p><p>二叉树的最大深度 <a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/">https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/</a></p><p>听别人说还有两数相加（链表）<a href="https://leetcode.cn/problems/lMSNwu/description/">https://leetcode.cn/problems/lMSNwu/description/</a></p><p>总结：</p><p>八股和简历相关性大并且问题与部门相关性大，岗位知识少，主要拷打做过的东西和学过的，一定要掌握。手撕写得不好，有缺陷，可能因为八股答得不咋样简单手撕也没撕出来就挂了吧。数据结构要复习，另外就是还是缺乏和软件相关性大的项目导致问硬件偏多，而且又没有准备，答得很差。</p><h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><h2 id="全局变量和静态全局变量的区别"><a href="#全局变量和静态全局变量的区别" class="headerlink" title="全局变量和静态全局变量的区别"></a>全局变量和静态全局变量的区别</h2><p>作用域不同：</p><p>全局变量具有全局作用域。全局变量只需在一个源文件中定义，就可以作用于所有的源文件。其他不包含全局变量定义的源文件需要用extern关键字再次声明这个全局变量。</p><p>静态全局变量也具有全局作用域，它与全局变量的区别在于<u>如果程序包含多个文件的话，它作用于定义它的文件里，不能作用到其它文件里，即被static关键字修饰过的变量具有文件作用域</u>。这样即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量。</p><p>（全局变量、静态全局变量都在<strong>静态存储区</strong>分配空间）</p><h2 id="inline函数"><a href="#inline函数" class="headerlink" title="inline函数"></a>inline函数</h2><p>内联函数。如果一个函数是内联的，编译时，编译器会把该函数的代码副本放置在每个调用该函数的地方。</p><p><code>inline int Max(int a, int b)&#123;&#125;</code></p><p>在类定义中定义的函数都是内联函数，即使没有使用inline说明符。</p><p>使用内联函数可以避免频繁调用函数对栈内存重复开辟带来的消耗。当函数被声明为内联函数之后, 编译器会将其内联展开, 而不是按通常的函数调用机制进行调用。</p><p>只有当函数只有 10 行甚至更少时才将其定义为内联函数。</p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>一种以[key-value]形式存储数据的数据结构。插入和查找的时间复杂度都是O(1)。</p><p><img src="/%E5%85%AB%E8%82%A1%E6%80%BB%E7%BB%93/image-20240507212319641.png" alt="image-20240507212319641"></p><p>哈希冲突：多个键值索引到同一个地方。</p><p>通常解决哈希冲突的方法：开放地址法、链表法</p><p>开放地址法从哈希表中再寻找一个空位解决冲突，链表法更加常用，每个数组对应一条链表，直接将新冲突的数据项添加到链表中，不需要从原始数组中寻找空位来存储。</p><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>用数组模拟栈</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">st = [<span class="number">0</span>]*N</span><br><span class="line"></span><br><span class="line"><span class="comment"># st[0]代表栈中元素数量，同时也是栈顶下标</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#压栈：</span></span><br><span class="line">st[st[<span class="number">0</span>]+<span class="number">1</span>] = var1</span><br><span class="line">st[<span class="number">0</span>] += <span class="number">1</span></span><br><span class="line"><span class="comment">#取栈顶</span></span><br><span class="line">u = st[st[<span class="number">0</span>]]</span><br><span class="line"><span class="comment">#弹栈：(注意越界)</span></span><br><span class="line"><span class="keyword">if</span> st[<span class="number">0</span>]:</span><br><span class="line">    st[<span class="number">0</span>] = st[<span class="number">0</span>] - <span class="number">1</span></span><br><span class="line"><span class="comment">#清栈</span></span><br><span class="line">st[<span class="number">0</span>] = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>在Python中可以使用列表来模拟一个栈</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">st = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">st.append(<span class="number">5</span>)</span><br><span class="line">st.append(<span class="number">4</span>)</span><br><span class="line"><span class="comment"># [1,2,3,5,4]</span></span><br><span class="line"></span><br><span class="line">st.pop()</span><br><span class="line"><span class="comment"># [1,2,3,5]</span></span><br><span class="line"><span class="comment"># 清栈</span></span><br><span class="line">st.clear()</span><br></pre></td></tr></table></figure><h2 id="用两个队列实现一个栈"><a href="#用两个队列实现一个栈" class="headerlink" title="用两个队列实现一个栈"></a>用两个队列实现一个栈</h2><p>leetcode225题</p><p>用单队列也可以实现，让栈顶元素始终保持在队首就可以了，只要保证先入后出规则，不需要在意队列内的顺序。</p><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="浏览器输入一个URL到获取网页的过程"><a href="#浏览器输入一个URL到获取网页的过程" class="headerlink" title="浏览器输入一个URL到获取网页的过程"></a>浏览器输入一个URL到获取网页的过程</h2><p>输入URL地址</p><p>应用层进行DNS解析</p><p>应用层生成HTTP请求报文</p><p>传输层建立TCP连接</p><p>网络层使用IP协议来选择路线</p><p>数据链路层实现网络相邻节点间可靠的数据通信</p><p>物理层传输数据</p><p>服务器处理反向传输</p><p>服务器返回一个HTTP响应</p><p>浏览器渲染</p><p>包括的协议：HTTP \ DNS \ TCP \ IP \ PPP </p><h2 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h2><p>即address resolution protocol，地址解析协议。通过ARP协议可以通过IP地址获取对方主机的MAC地址。</p><p>如果未知MAC地址，在封装MAC帧时就无法填写目的MAC地址。</p><p>ARP高速缓存表中如果查找不到对应的MAC地址，则广播ARP请求报文。对应主机收到之后，单播一个ARP响应报文。</p><p>ARP高速缓存表中的每一条记录都有类型，分为静态和动态。动态类型为主机自动获取的，生命周期默认为两分钟，因为IP地址与MAC地址的对应关系并不是永久性的。主机更换网卡，IP地址并不会发生改变，但MAC地址会变。</p><p>静态类型是指记录是用户或网络维护人员手工配置的，不同操作系统下的生命周期不同，例如系统重启后不存在或系统重启后依然有效。</p><p>ARP协议只能在一段链路或一个网络上使用，不能跨网络使用。ARP协议的使用是逐段链路进行的。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python装饰器</title>
      <link href="/2024/04/29/python%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
      <url>/2024/04/29/python%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>可以简单理解成修改其他函数的功能的函数。</p><h1 id="Cache装饰器"><a href="#Cache装饰器" class="headerlink" title="@Cache装饰器"></a>@Cache装饰器</h1><p>为了提高函数的执行效率并减少重复计算，用缓存来存储已经计算过的结果。</p><p>位于Python标准库functools模块中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> cache </span><br><span class="line"></span><br><span class="line"><span class="meta">@cache</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fibonacci_width_cache</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> fibonacci_with_cache(n-<span class="number">1</span>) + fibonacchi_with_cache(n-<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>使用装饰器通过缓存避免重复计算。</p><p>❗注意：</p><p>@cache装饰器会将函数的参数作为缓存的键，因此在使用缓存时需要<strong>保证函数的参数是可哈希的</strong>。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>[1] <a href="https://mp.weixin.qq.com/s/ZfcC7_Uk6E4ViUv4b9DBUQ">harvey的网络日志</a></p><p>[2] <a href="https://www.runoob.com/w3cnote/python-func-decorators.html">Python函数装饰器</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 装饰器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux学习</title>
      <link href="/2024/04/25/Linux%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/04/25/Linux%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>本文为Linux基础学习过程的记录。</p><span id="more"></span><h1 id="为什么要用linux"><a href="#为什么要用linux" class="headerlink" title="为什么要用linux"></a>为什么要用linux</h1><blockquote><p>很多开发要求使用Linux系统的原因主要涉及到开发环境的兼容性、工具链、性能、安全性等方面。尽管Windows也可以用于开发，但以下是为什么Linux通常被认为是更合适的选择的主要原因：</p><ol><li><strong>兼容性和一致性</strong>：<ul><li><strong>服务器环境一致性</strong>：大多数服务器运行的是Linux操作系统。在本地开发环境中使用Linux，可以确保开发环境与生产环境一致，减少环境差异导致的问题。</li><li><strong>容器化和虚拟化</strong>：Linux在容器化（如Docker）和虚拟化技术方面有很强的支持，开发者可以轻松创建和管理开发环境。</li></ul></li><li><strong>开发工具和包管理</strong>：<ul><li><strong>丰富的开发工具</strong>：许多开发工具和库首先在Linux上发布和优化，例如GCC编译器、GDB调试器、Make构建工具等。</li><li><strong>包管理系统</strong>：Linux发行版通常具有强大的包管理系统（如APT、Yum、Pacman），方便安装、更新和管理软件包和依赖。</li></ul></li><li><strong>开源生态系统</strong>：<ul><li><strong>开源软件支持</strong>：Linux本身是开源的，许多开源项目和工具优先支持Linux平台。使用Linux有助于开发者更好地利用和贡献开源社区的资源。</li><li><strong>源代码访问</strong>：在Linux环境中，开发者可以轻松访问和修改操作系统及许多工具的源代码，有助于定制和优化开发环境。</li></ul></li><li><strong>性能和资源管理</strong>：<ul><li><strong>高效的资源使用</strong>：Linux系统通常在资源管理和性能上表现出色，适合需要高效处理和大规模并发的开发任务。</li><li><strong>轻量级环境</strong>：Linux可以配置为轻量级环境，减少开发机的系统开销，提高开发效率。</li></ul></li><li><strong>自动化和脚本支持</strong>：<ul><li><strong>强大的脚本支持</strong>：Linux支持多种脚本语言（如Bash、Python），方便开发者进行任务自动化、构建脚本、持续集成&#x2F;持续部署（CI&#x2F;CD）等操作。</li><li><strong>命令行工具</strong>：Linux拥有丰富且强大的命令行工具，可以进行各种系统管理和开发任务，提升开发效率。</li></ul></li><li><strong>网络和服务器开发</strong>：<ul><li><strong>网络工具和服务</strong>：Linux内置了许多强大的网络工具和服务，适合网络编程、服务器开发和系统管理。</li><li><strong>系统调用和内核开发</strong>：许多底层开发（如系统调用、驱动程序和内核模块开发）需要在Linux上进行，因为Linux的内核和系统调用接口开放且文档齐全。</li></ul></li><li><strong>安全性和权限管理</strong>：<ul><li><strong>严格的权限管理</strong>：Linux系统的权限管理严格，可以有效控制用户和进程的权限，增强开发环境的安全性。</li><li><strong>安全工具和机制</strong>：Linux有许多内置的安全工具和机制，有助于开发和测试安全应用。</li></ul></li><li><strong>学习和社区支持</strong>：<ul><li><strong>学习曲线</strong>：使用Linux有助于开发者深入理解操作系统和底层机制，提升技术水平。</li><li><strong>社区支持</strong>：Linux有一个庞大的开发者社区，提供大量的学习资源、支持和协作机会。</li></ul></li></ol><p>虽然Windows也可以用于开发，并且Windows Subsystem for Linux (WSL) 提供了在Windows上运行Linux工具的途径，但对于许多开发任务，特别是涉及到服务器、网络、系统编程和开源项目的开发，Linux仍然是更自然和高效的选择。</p></blockquote><h1 id="vim-vi"><a href="#vim-vi" class="headerlink" title="vim &amp; vi"></a>vim &amp; vi</h1><p>vi编辑器是Unix系统下的一款文本编辑器，vim是vi improved的缩写，是vi编辑器的增强版。</p><p>在命令行中输入vi或者vim就会进入到vim的界面。</p><p>vi有三种常用的模式，分别是命令模式、插入模式和尾行模式。不同的模式可以通过快捷键来切换。</p><p>vi 文件名 来打开一个文件，如果文件不存在就会创建一个新的文件。</p><!--more--><h3 id="命令模式-command-mode"><a href="#命令模式-command-mode" class="headerlink" title="命令模式(command mode)"></a>命令模式(command mode)</h3><p>进入到vim默认的就是命令模式。</p><p>按下ESC键回到命令模式。</p><p>使用h j k l四个键来控制光标的移动，分别代表左下上右</p><p>^ 代表行首 $代表行尾（跳转到）</p><p>连续按下两个y键复制一行内容，再按p键就可以将复制的内容粘贴到光标的下一行，每按下一次p键就会粘贴一次。</p><p>dd 删除一行内容，同样也可以用p来粘贴。</p><p>可以类比为windows中的ctrl+C ctrl+V 和 ctrl +X</p><p>tips: 只需要在这几个快捷键前加上一个数字，就可以表示复制或者粘贴的次数</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ctrl+<span class="keyword">f</span>(forward) 向前翻页</span><br><span class="line">ctrl+<span class="keyword">b</span>(backward) 向后翻页</span><br><span class="line">ctrl+<span class="keyword">u</span>(<span class="keyword">up</span>) 向上翻半页</span><br><span class="line">ctrl+d(down) 向下翻半页</span><br><span class="line">G 快速跳转到文件的最后一行</span><br><span class="line">gg 跳转到文件的第一行</span><br><span class="line">行号 G 跳转到指定的某一行</span><br><span class="line">/ 从光标所在位置开始向下查找</span><br><span class="line">? 从光标所在位置向上查找</span><br><span class="line">n 继续查找下一个（相对于当前的查找方向）</span><br><span class="line">查找区分大小写</span><br><span class="line">\<span class="keyword">c</span> 忽略大小写</span><br><span class="line">/查找内容\<span class="keyword">c</span></span><br></pre></td></tr></table></figure><h3 id="尾行模式（Last-line-mode"><a href="#尾行模式（Last-line-mode" class="headerlink" title="尾行模式（Last line mode)"></a>尾行模式（Last line mode)</h3><p>冒号是尾行模式的标志。在命令模式下输入一个冒号之后就会进入到尾行模式。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">:<span class="keyword">wq</span> 保存文件并退出<span class="keyword">vi</span></span><br><span class="line">:<span class="keyword">set</span> <span class="keyword">number</span> 显示行号 缩写：:<span class="keyword">set</span> <span class="keyword">nu</span></span><br><span class="line">:<span class="keyword">set</span> nonumber 关闭行号显示</span><br><span class="line">:<span class="keyword">set</span> ic 即ignore case，全局忽略大小写</span><br><span class="line">:行号，行号s/查找内容/替换内容/g s表示替换，g表示全局</span><br></pre></td></tr></table></figure><h3 id="插入模式-Insert-mode"><a href="#插入模式-Insert-mode" class="headerlink" title="插入模式(Insert mode)"></a>插入模式(Insert mode)</h3><p>插入内容。可以在命令模式下通过键盘上的i键，a键和o键来进入插入模式（insert&#x2F;append&#x2F;open）。</p><p>大小写是有区别的。</p><p><img src="/linux%E5%AD%A6%E4%B9%A0/image-20240426094631573.png" alt="image-20240426094631573"></p><hr><p>快捷键u表示撤销</p><h2 id="vimrc"><a href="#vimrc" class="headerlink" title=".vimrc"></a>.vimrc</h2><p>用来保存vi的配置信息，每次打开vi都会自动加载其中的配置。</p><h1 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">ls -l 显示更详细的信息</span><br><span class="line">ls -a 显示包括隐藏文件在内的所有文件</span><br><span class="line">在linux中，以半角英文的点开头的文件和目录都是隐藏的</span><br><span class="line">ls -h 以人类可读的方式显示文件的大小</span><br><span class="line">ls -t 按照修改时间排序</span><br><span class="line">ls -r 逆序显示</span><br><span class="line">组合使用： ls -ltr</span><br><span class="line">显示的第一列是文件的类型和权限</span><br><span class="line">列表中第二列的数字表示文件的硬链接数</span><br><span class="line">第一列后的九个字符表示的是文件的权限。</span><br><span class="line">- 表示普通文件</span><br><span class="line"></span><br><span class="line">d 表示目录</span><br><span class="line">l 表示链接文件</span><br><span class="line">ln 源文件名词 链接文件名称  创建链接文件（ln代表link），默认为硬链接文件</span><br><span class="line">ln -s 创建软链接文件</span><br><span class="line"></span><br><span class="line">chmod +x 文件名 添加文件可执行权限</span><br><span class="line">chmod -r 对象 删除权限</span><br><span class="line">chmod u+x 对象 只给文件的所有者添加可执行权限</span><br><span class="line">chmod ug+x 对象 为文件的所有者和所属组添加可执行权限</span><br><span class="line">直接使用数字来修改权限 rwx对应421</span><br><span class="line">chmod 777 对象 所有的用户都具有读写和执行的权限</span><br><span class="line"></span><br><span class="line">touch 更新文件的修改时间，如果文件不存在，会自动创建一个新的空文件</span><br><span class="line"></span><br><span class="line">echo 输出文本</span><br><span class="line">echo &quot;Hello&quot;</span><br><span class="line">也可以配合重定向符号用来保存内容</span><br><span class="line">echo &quot;Hello&quot; &gt; hello.txt 把原本要输入到屏幕上的内容重定向到文件中</span><br><span class="line">文件不存在时，同样会自动创建文件</span><br><span class="line"></span><br><span class="line">pwd (print woring directory) 显示当前所在目录的位置</span><br><span class="line">cd (change directory) 切换目录</span><br><span class="line">cd / 切换到根目录</span><br><span class="line"></span><br><span class="line">cp 复制文件/目录</span><br><span class="line">mv 移动文件/目录 或 重命名文件</span><br><span class="line">mkdir 创建目录</span><br><span class="line">mkdir -p 创建多级目录</span><br><span class="line">cp无法直接复制目录，cp -r 递归复制才能复制目录</span><br><span class="line">rmdir 删除目录</span><br><span class="line">目录非空时会报错，此时应使用rm -r</span><br><span class="line">rm操作是危险的，因为是不可逆的</span><br><span class="line"></span><br><span class="line">du(disk usage) 查看文件大小</span><br><span class="line">tree 以树状图的形式显示目录的结构（非自带命令，需要安装</span><br></pre></td></tr></table></figure><h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><blockquote><p>.bash_profile 保存用户配置信息</p><p>.ssh 保存SSH密钥</p></blockquote><p>链接文件是Linux系统中的一种特殊文件，分为硬链接和软链接。软链接也叫符号链接，类似于Windows系统中的快捷方式。</p><p>软链接文件本身其实并不存储文件的内容，它只是一个指向目标文件的快捷方式，所以软链接文件的大小非常小。</p><p>硬链接本质上是一个指向文件系统中另一个文件的指针，与原始文件共享相同的i节点。这意味着它们共享相同的文件内容。</p><p>把软链接的目标文件删除的时候，软链接文件就会失效。此时ls查看时文件名会变成红色，表示链接文件已失效。</p><p>软链接和硬链接的区别之二就是软链接可以指向文件或目录，硬链接只能指向文件。</p><p>在Linux中，文件系统是一个树状结构，所有的文件和目录都是从根目录开始的，根目录的符号是 &#x2F; 。</p><p>相对路径使用一个点来表示当前目录，使用两个点来表示上一层目录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/bin 存放系统的基本命令以及一些二进制的可执行文件，bin即binary的缩写</span><br><span class="line">/etc 存放系统和一些软件的配置文件</span><br><span class="line">/home 用户的家目录</span><br><span class="line">/sbin 系统二进制文件</span><br><span class="line">/dev 设备文件</span><br><span class="line">/root root用户家目录</span><br><span class="line">/lib 系统库目录</span><br><span class="line">/opt 可选的第三方软件包</span><br><span class="line">/tmp 临时文件</span><br><span class="line">/usr 用户程序</span><br><span class="line">/var 可变文件如日志等</span><br><span class="line">/boot 启动加载器文件</span><br><span class="line">/proc 进程信息</span><br><span class="line">/sys 系统文件</span><br></pre></td></tr></table></figure><h1 id="Concept"><a href="#Concept" class="headerlink" title="Concept"></a>Concept</h1><p><strong>inode(index node)</strong></p><p>​是文件系统中的概念。在linux中，每个文件或者目录都有一个唯一的i节点，存储了文件的元数据信息，包括了文件的权限、所有者、大小、修改时间等等。</p><h2 id="ls查看的权限"><a href="#ls查看的权限" class="headerlink" title="ls查看的权限"></a>ls查看的权限</h2><p>例如：rw-rw-r–</p><p>可以划分为3个字符一组，第一组表示文件所有者的权限，第二组表示文件所属组别的权限，第三组表示其他用户的权限。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r 可读</span><br><span class="line">w 可写</span><br><span class="line">x 可执行</span><br><span class="line">- 无相应权限</span><br></pre></td></tr></table></figure><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>[1] <a href="https://www.bilibili.com/video/BV1cq421w72c/?spm_id_from=333.1007.tianma.2-2-5.click&vd_source=619ca0a91236fa2e514bd44a58491205">【GeekHour】30分钟Linux入门教程</a> 2024&#x2F;4&#x2F;27</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多通道气体传感器</title>
      <link href="/2024/04/23/%E5%A4%9A%E9%80%9A%E9%81%93%E6%B0%94%E4%BD%93%E4%BC%A0%E6%84%9F%E5%99%A8/"/>
      <url>/2024/04/23/%E5%A4%9A%E9%80%9A%E9%81%93%E6%B0%94%E4%BD%93%E4%BC%A0%E6%84%9F%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Arduino库"><a href="#Arduino库" class="headerlink" title="Arduino库"></a>Arduino库</h1><h2 id="MultichannelGasSensor-c"><a href="#MultichannelGasSensor-c" class="headerlink" title="MultichannelGasSensor.c"></a>MultichannelGasSensor.c</h2><p>定义MultichannelGasSensor类，初始化变量</p><blockquote><p>begin() 初始化I2C，根据传入的地址确定版本号</p><p>getVersion() 获取传感器模块的版本号，根据返回值来判断具体的版本</p><p>sendI2C() 用于向I2C设备发送数据</p><p>get_addr_dta() 用于从指定地址读取数据，可用于读取传感器的各种值</p><p>readData() 用于读取R0值，存储在从机MCU中</p><p>readR() 读取每个通道的电阻值</p><p>calcGas() 计算每个通道的气体浓度</p><p>changeI2CAddr() 用于更改从机的I2C地址</p><p>doCalibrate() 执行校准过程</p><p>powerOn() 和 powerOff() 用于开启和关闭传感器</p><p>factory_setting() 恢复传感器模块的出厂设置</p><p>change_i2c_address() 改变从机的I2C地址</p></blockquote><span id="more"></span><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="Arduino库移植到Linux下"><a href="#Arduino库移植到Linux下" class="headerlink" title="Arduino库移植到Linux下"></a>Arduino库移植到Linux下</h2><p>替换库函数：Wire.h替换为I2C库，替换delay()为linux下的延时函数</p><p>在Linux下，可以使用’&#x2F;dev&#x2F;i2c-x’设备文件来进行I2C通信，使用read()和write()函数进行数据的读写操作</p><p>具体来说，根据每个函数的功能，分别寻找Linux下对应的函数或者库进行替换。open()函数打开设备文件，ioctl()函数设置I2C地址。</p><p>通常，与硬件相关的函数（如I2C通信、延时）以及与Arduino库紧密相关的函数（如Wire库中的函数、串口通信函数）需要较大程度的移植或重写。</p><p>而一些逻辑上独立、与平台无关的函数可能可以直接在Linux下使用，如数据处理函数和控制逻辑函数。</p><p>通常情况下，Linux 中的 I2C 设备读取函数返回的是一个字节序列，而不是像 Arduino 中一样直接读取四个字节。因此，在 Linux 中你需要对读取的字节进行适当的解析以得到你所需的数据。</p><p><code>i2c_smbus_read_byte_data</code> 函数是 Linux 提供的用户空间 I2C 接口函数之一，用于从 I2C 设备中读取一个字节的数据。它通常是通过调用 Linux 提供的 <code>i2c-dev.h</code> 头文件中的宏定义来实现的。</p><h2 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h2><p>声明buffer[4]，调用sendI2C，延迟2ms，等待传感器响应，使用I2C协议向传感器请求4个字节的数据。</p><p>在传感器数据可用之前进行循环等待，如果超时次数大于100次则返回-2表示超时错误。</p><p>再次延迟2ms，如果接收到的数据长度不为4，则返回-3表示数据长度错误。</p><p>从传感器中读取的数据存储在buffer数组中，计算校验和 checksum &#x3D; (uint8_t)(buffer[0] + buffer[1] + buffer[2]);</p><p>检查校验和是否正确 checksum!&#x3D;buffer[3]，不正确就返回-4表示检验和错误</p><p>rtnData &#x3D; ((buffer[1] &lt;&lt; 8) + buffer[2]) 将接收到的数据组合成一个16位整数，并存储在rtnData变量中</p><h2 id="读取初始电阻值R0"><a href="#读取初始电阻值R0" class="headerlink" title="读取初始电阻值R0"></a>读取初始电阻值R0</h2><p>R0值是传感器在特定条件下的基准电阻值，用于后续计算气体浓度。</p><p>0x11、0x12、0x13代表不同通道的命令码，根据返回的数据是否大于0来判断读取是否成功，将读取到的数据存储在res0数组中。</p><p>如果读取到的数据小于等于0，则表示读取失败，函数会返回读取到的数据。读取成功，返回1表示成功。</p><h2 id="读取气体浓度数据"><a href="#读取气体浓度数据" class="headerlink" title="读取气体浓度数据"></a>读取气体浓度数据</h2><p>调用readData分别获取三个通道（通道0、1、2）的气体浓度数据，每个通道对应的命令是0x01、0x02和0x03，存储在数组rtnData中。</p><h2 id="计算气体浓度"><a href="#计算气体浓度" class="headerlink" title="计算气体浓度"></a>计算气体浓度</h2><p>通过readR0()读取基准电阻，存储在res0数组中，通过ReadR()读取气体浓度相关数据，存储在res数组中。</p><p>根据传入的气体类型计算相应的气体浓度，不同的气体类型对应不同的计算公式。</p><p>CO的计算公式：c &#x3D; pow(ratio1, -1.179) * 4.385;</p>]]></content>
      
      
      <categories>
          
          <category> 物联网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 传感器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue项目实战</title>
      <link href="/2024/04/21/Vue%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"/>
      <url>/2024/04/21/Vue%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>为做物联网项目而学习本项目，为方便后续复习而记录。</p><span id="more"></span><h1 id="项目搭建"><a href="#项目搭建" class="headerlink" title="项目搭建"></a>项目搭建</h1><p>Vue CLI项目结构：</p><p>build(webpack的初始化配置)</p><p>config(index.js)</p><p>node_modules(项目依赖模块)</p><h1 id="登录页面开发"><a href="#登录页面开发" class="headerlink" title="登录页面开发"></a>登录页面开发</h1><p>前后端分离: 前后端之间通过 RESTful API传递JSON数据进行交流。</p><p>后端不涉及页面本身的内容。开发时，前端用前端的服务器（Nginx），后端用后端的服务器（Tomcat）。通过反向代理（将前端的请求通过前端服务器转发给后端）实时观察结果，不需要知道后端的实现内容，只需要知道接口提供的功能。</p><p>正向代理是用户主动去访问代理服务器，反向代理是代理服务器主动将信息提供给用户，用户并不知道有代理过程，反向代理可以保护服务器，不暴露服务器的真实地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    用户名：&lt;input typr=&quot;text&quot; v-model=&quot;loginForm.username&quot; placeholder=&quot;请输入用户名&quot;/&gt;</span><br><span class="line">    &lt;br&gt;&lt;br&gt;</span><br><span class="line">    密码: &lt;input type=&quot;password&quot; v-model=&quot;loginForm.password&quot; placeholder=&quot;&quot;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p><img src="/Vue%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20240426194014906.png" alt="默认界面"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>author: Evan-Nightly [Vue + Spring Boot项目实战]</p><p><a href="https://blog.csdn.net/neuf_soleil/category_9287210.html">https://blog.csdn.net/neuf_soleil/category_9287210.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="/2024/04/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2024/04/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>八大排序：桶排序、冒泡排序、选择排序、插入排序、快速排序、希尔排序、归并排序、堆排序。</p><span id="more"></span><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>重复地走访并交换。时间复杂度为O(n^2)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) - i - <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> nums[j] &gt; nums[j+<span class="number">1</span>]:</span><br><span class="line">                    nums[j], nums[j+<span class="number">1</span>] = nums[j+<span class="number">1</span>], nums[j]</span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git学习</title>
      <link href="/2024/04/12/git%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/04/12/git%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>单调栈</title>
      <link href="/2024/04/11/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
      <url>/2024/04/11/%E5%8D%95%E8%B0%83%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>739.每日温度</p><p>暴力解法会超过时间限制。</p><p>维护一个单调栈，栈中存放的是温度数组各元素的下标而不是温度值，但单调性根据温度值来维护。</p><p>核心代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">while</span> st <span class="keyword">and</span> temperatures[st[-<span class="number">1</span>]] &lt;= temperatures[i]:</span><br><span class="line">                st.pop()</span><br><span class="line">            <span class="keyword">if</span> st:</span><br><span class="line">                answer[i] = st[-<span class="number">1</span>] - i</span><br><span class="line">            st.append(i)</span><br></pre></td></tr></table></figure><p>比如输入是30，60，90。单调栈存的就是 [3 2 1] 栈顶对应的温度值为30。为了保证先入后出，从后往前遍历。存下标的话，因为我们有原数组，相当于可以映射过去也就有了实际的温度值，如果存实际的温度值就会丢失下标的信息量，并且答案实际也是要从下标推出来的，所以实际上是从单调栈线性推出答案，这就是单调栈的优越性。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现简单Web服务器</title>
      <link href="/2024/04/09/%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95Web%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2024/04/09/%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95Web%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>目前急需开发经验并且Python已经到了可以进阶的阶段。该项目和HTTP协议相关，故选此项目进行学习。</p><span id="more"></span><h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><p>CSS： Cascading Style Sheets，层叠样式表，是一种用来为结构化文档（例如HTML文档或XML应用）添加样式(字体、间距和颜色等)的计算机语言。</p><p>HTML： HyperText Markup Language，超文本标记语言，是一种用于创建网页的标准标记语言</p><p>浏览器背后的这些文件都是通过HTTP从服务器传输到浏览器（即客户端）。</p><p>HTTP： HyperText Transfer Protocol，遵循从客户端发出请求到服务器并等待响应的模型，因此也被认为是“请求–响应协议”。</p><p>DNS是一个分布式数据库，DNS服务器集群是分层级的，没有任何一个单一的DNS服务器中包含所有数据。</p><h2 id="无状态的（Statelessness）"><a href="#无状态的（Statelessness）" class="headerlink" title="无状态的（Statelessness）"></a><strong>无状态的（Statelessness）</strong></h2><p>协议的每一个请求&#x2F;响应周期与前一个都是互相独立的。</p><p>无状态协议对于服务器资源和易用性的影响：服务器不需要再各次请求之间保留状态信息，请求出问题系统不需要清理。</p><p>但也因此HTTP协议很难构建有状态的应用，开发人员需要模拟web应用中的有状态体验，比如如何维持用户登录状态，怎么区分用户。</p><p>Web是灵活的、去中心化的，但也难以控制，安全性难以保证，构建应用并不简单。</p><p>URL： Uniform Resource Locator，统一资源定位符。由URL模式+资源路径或主机+URL路径构成。</p><p>常见的URL模式包括HTTP、FTP、Mailto、Git</p><p>URL可以包含一个主机用来监听HTTP请求的端口号。Web客户端用来监听HTTP请求的默认端口号是80，如果一个URL中没有指定其他的端口号，默认为80。</p><h2 id="查询字符串-参数"><a href="#查询字符串-参数" class="headerlink" title="查询字符串&#x2F;参数"></a>查询字符串&#x2F;参数</h2><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.example.com?search=ruby&amp;results=10</span><br></pre></td></tr></table></figure><p>? 为保留字，标识着查询字符串的开始</p><p>search&#x3D;ruby  results &#x3D; 10  都是参数的键值对</p><p>&amp; 保留字，需要给查询字符串添加参数时使用</p><p>查询字符串的限制：有最大长度、键值对会显示（不能用来传输敏感信息）、无法使用空格和特殊字符（必须用URL编码替代）</p><h2 id="URL编码"><a href="#URL编码" class="headerlink" title="URL编码"></a>URL编码</h2><p>URL默认只接受ASCII码，不安全的或者不是ASCII码的字符要进行转义或者编码。</p><p>HTTP GUI工具：</p><p><a href="https://www.telerik.com/fiddler">https://www.telerik.com/fiddler</a></p><p>现代浏览器查看HTTP请求和响应的方法叫审查器。</p><h1 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h1><ul><li>HTTP协议基本原理</li><li>Python3实现网络开发</li><li>Web服务请求响应</li><li>CGI协议</li><li>响应错误处理实现</li><li>面向对象方法重构代码</li><li>Web服务器框架</li></ul><p>Web服务器的基本概念：</p><p>​    1、等待有人连接服务器并发送一个HTTP请求</p><p>​    2、解析请求</p><p>​    3、了解该请求希望请求的内容</p><p>​    4、服务器根据请求抓取需要的数据（从本地读取或者动态生成）</p><p>​    5、将数据格式化为请求需要的格式</p><p>​    6、返回HTTP响应</p><p>使用Python标准库中的BaseHTTPServer模块处理步骤1、2、6</p><p>终端打印的响应信息：（显示了响应报文的全部内容）</p><p><img src="/%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95Web%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20240409230905091.png" alt="image-20240409230905091"></p><p><img src="/%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95Web%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20240410180834812.png" alt="image-20240410180834812"></p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 前端 </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无重复字符的最长子串</title>
      <link href="/2024/04/04/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
      <url>/2024/04/04/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<p>LCR 016</p><p>给定一个字符串s，请你找出其中不含有重复字符的最长连续子字符串的长度。</p><span id="more"></span><blockquote><p>注意是子串，不是子序列。子序列不要求连续</p></blockquote><h1 id="自解"><a href="#自解" class="headerlink" title="自解:"></a>自解:</h1><p>采用双指针，一个从第一个字符开始向后遍历，第二个指针在第一个指针不变的基础上向后遍历，这样相当于所有的子串都能被遍历到。</p><p>感觉逻辑上没有问题不代表代码没有问题 &#x3D;)</p><p>一开始想用嵌套for循环，然后判断如果第二个指针指向的字符不在已更新的子串中并且长度大于已记录的最大值就进行更新，如果在已更新的字符串中就放弃该子串，将S更新为空。</p><p>这种思路貌似没有问题，但是其实有很多逻辑上的缺陷，导致根本不可能得到正确答案。首先，S的更新并不全面，判断并没有包含全部的情况。然后就是对字符串不熟练导致调试花了很多时间。</p><p><img src="/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/image-20240404150442148.png" alt="image-20240404150442148"></p><p>Python中字符串的切片：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字符串[开始索引:结束索引:步长]</span><br></pre></td></tr></table></figure><p>属于左闭右开的区间，所以这里取s[i:j] 根本没有取到s[j]。子串的更新上就已经不对了。</p><p>对代码进行更改，依然是双指针的思想，不同的是，双指针都不用for循环进行递加，而是根据判断条件进行自加。</p><p>利用子串的连续性，用append而不是切片的方式进行子串构建。而且并不是大于最大长度才更新子串，子串是一直更新的，但大于最大长度才会更新最大值。如果j指向的字符在子串中说明不能再加了，这就是从i的位置能得到的最长子串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLongestSubstring</span>(<span class="params">self, s</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        maxlength = <span class="number">1</span>                                </span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        j = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> s == <span class="string">&quot;&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        S =  [s[i]]</span><br><span class="line">        <span class="keyword">while</span> j &lt; <span class="built_in">len</span>(s):</span><br><span class="line">            <span class="keyword">if</span> s[j] <span class="keyword">not</span> <span class="keyword">in</span> S:</span><br><span class="line">                S.append(s[j])</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(S) &gt; maxlength:</span><br><span class="line">                    maxlength = <span class="built_in">len</span>(S)</span><br><span class="line">            <span class="keyword">elif</span> s[j] <span class="keyword">in</span> S:</span><br><span class="line">                i = i + <span class="number">1</span></span><br><span class="line">                S = [s[i]]</span><br><span class="line">                j = i</span><br><span class="line">            j = j + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> maxlength</span><br></pre></td></tr></table></figure><h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><p>依次递增地枚举子串的起始位置，那么子串的结束位置也是递增的。根据这个特点才能使用滑动窗口。</p><p>使用两个指针表示字符串中某个子串（或窗口）的左右边界，左指针代表着枚举子串的起始位置，右指针为子串的结束位置（不到重复字符可以继续递增）</p><p>枚举的过程和自解的想法是相似的。</p><h3 id="判断重复字符"><a href="#判断重复字符" class="headerlink" title="判断重复字符"></a>判断重复字符</h3><p>使用数据结构来判断是否有重复的字符，常用的数据结构为<strong>哈希集合</strong>。C++中的 std::unordered_set，Java中的HashSet，Python中的set，JavaScript中的Set。在左指针向右移动的时候，我们从哈希集合中移除一个字符，在右指针向右移动的时候，我们往哈希集合中添加一个字符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 哈希集合，记录每个字符是否出现过</span></span><br><span class="line">        occ = <span class="built_in">set</span>()</span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="comment"># 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动</span></span><br><span class="line">        rk, ans = -<span class="number">1</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> i != <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 左指针向右移动一格，移除一个字符</span></span><br><span class="line">                occ.remove(s[i - <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">while</span> rk + <span class="number">1</span> &lt; n <span class="keyword">and</span> s[rk + <span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> occ:</span><br><span class="line">                <span class="comment"># 不断地移动右指针</span></span><br><span class="line">                occ.add(s[rk + <span class="number">1</span>])</span><br><span class="line">                rk += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 第 i 到 rk 个字符是一个极长的无重复字符子串</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, rk - i + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p>set() 函数创建一个无序不重复元素集，会删除重复元素。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>这题是4.2腾讯测试与质量管理岗一面的考题。总体上感觉做法和自解差不多…但是当时不知道这个就叫滑动窗口。面试官提醒了用滑动窗口，但是碍于自身代码实力确实太弱，没改出来，也因为这个导致一面就挂了吧。</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 字符串 </tag>
            
            <tag> Leetcode </tag>
            
            <tag> 哈希表 </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode字符串篇</title>
      <link href="/2024/03/30/leetcode%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AF%87/"/>
      <url>/2024/03/30/leetcode%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<p>本篇为Leetcode做题过程中字符串篇的总结和纠错等记录。</p><span id="more"></span><p>分类：</p><ul><li>字符</li><li>回文串的定义</li><li>公共前缀</li><li>单词</li><li>字符串的反转</li><li>字符的统计</li><li>数字与字符串间转换</li><li>子序列</li><li>高精度运算</li><li>字符串变换</li><li>字符串匹配</li><li>中心拓展法</li></ul><hr><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p>要用Python做字符串类型的题，首先要了解Python内置了哪些处理字符串的函数或方法。</p><p><strong>isalnum()</strong></p><p>​如果string至少有一个字符并且所有字符都是字母或数字则返回True，否则返回False。</p><p><strong>filter()</strong></p><p>​用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表。该接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判断，将返回True的元素放到新列表中。</p><p><strong>join()</strong></p><p>​用于将序列中的元素以指定的字符连接生成一个新的字符串。用法为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>.join(item) <span class="comment"># 括号里只能有一个成员</span></span><br><span class="line"><span class="comment"># 例如：</span></span><br><span class="line"><span class="string">&#x27;,&#x27;</span>.join(<span class="string">&#x27;abc&#x27;</span>)</span><br><span class="line"><span class="comment"># 输出结果为：&#x27;a,b,c&#x27;</span></span><br><span class="line"><span class="string">&#x27;&#x27;</span>.join</span><br><span class="line"><span class="comment"># 将字符串中的所有大写字母转换为小写字母</span></span><br></pre></td></tr></table></figure><p>str[::-1] 字符反转 </p><p><strong>strip()</strong></p><p>​去除字符串开头或者结尾的空格</p><p><strong>get()</strong></p><p>​字典的方法，返回指定键的值。</p><p>​get(key, value) value可选，当键不在字典中返回value。默认返回None。</p><p>统计字符串中字符的数量：<code>for c in p: obj[c] = obj.get(c,0) + 1</code></p><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p><strong>S.toCharArray()</strong></p><p>​将字符串转为对应的字符串数组</p><h2 id="计算字符串重新排列数"><a href="#计算字符串重新排列数" class="headerlink" title="计算字符串重新排列数"></a>计算字符串重新排列数</h2><p>给定一个只包含大写英文字母的字符串S，要求你给出对S重新排列的所有不相同的排列数。</p><p>算法：</p><p>统计字符串中每个字符的出现次数。<br>计算字符总数的阶乘，这表示所有字符的排列数。<br>计算每个字符重复的次数的阶乘，并将这些阶乘相乘。<br>得到的结果就是不同排列的总数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> factorial</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">count_unique_permutations</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="comment"># 统计字符出现次数</span></span><br><span class="line">    counter = Counter(s)</span><br><span class="line">    <span class="comment"># 计算所有字符的排列数</span></span><br><span class="line">    total_permutations = factorial(<span class="built_in">len</span>(s))</span><br><span class="line">    <span class="comment"># 计算重复字符的阶乘并相乘</span></span><br><span class="line">    <span class="keyword">for</span> count <span class="keyword">in</span> counter.values():</span><br><span class="line">        total_permutations //= factorial(count)</span><br><span class="line">    <span class="keyword">return</span> total_permutations</span><br></pre></td></tr></table></figure><p>counter.values()返回Counter对象中所有计数的值，即字符串中每个字符的出现次数。</p><h2 id="字符的统计"><a href="#字符的统计" class="headerlink" title="字符的统计"></a>字符的统计</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> m:</span><br><span class="line"><span class="built_in">sum</span> = m.count(i) <span class="comment"># m中i的个数</span></span><br></pre></td></tr></table></figure><p>Java charAt()方法</p><ul><li>用于返回指定索引处的字符</li></ul><h2 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h2><p>交换两个值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a,b = b,a</span><br></pre></td></tr></table></figure><p>s[:] &#x3D; s[::-1] 是切片赋值语法，表示用s[::-1]替换s中的元素，注意不能写成s &#x3D; s[::-1]，因为s是形参，修改s不会影响函数外部传入的实参。注意这不是原地操作，需要O(n)的额外空间。</p><h1 id="字符串算法篇"><a href="#字符串算法篇" class="headerlink" title="字符串算法篇"></a>字符串算法篇</h1><h2 id="字符串匹配算法"><a href="#字符串匹配算法" class="headerlink" title="字符串匹配算法"></a>字符串匹配算法</h2><h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><p>例：28.找出字符串第一个匹配项的下标</p><p>给你两个字符串 <code>haystack</code> 和 <code>needle</code> ，请你在 <code>haystack</code> 字符串中找出 <code>needle</code> 字符串的第一个匹配项的下标（下标从 0 开始）。如果 <code>needle</code> 不是 <code>haystack</code> 的一部分，则返回 <code>-1</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：haystack = &quot;sadbutsad&quot;, needle = &quot;sad&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：&quot;sad&quot; 在下标 0 和 6 处匹配。</span><br><span class="line">第一个匹配项的下标是 0 ，所以返回 0 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：haystack = &quot;leetcode&quot;, needle = &quot;leeto&quot;</span><br><span class="line">输出：-1</span><br><span class="line">解释：&quot;leeto&quot; 没有在 &quot;leetcode&quot; 中出现，所以返回 -1 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= haystack.length, needle.length &lt;= 104</code></li><li><code>haystack</code> 和 <code>needle</code> 仅由小写英文字符组成</li></ul><blockquote><p>参考来源：宫水三叶 <a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/575568/shua-chuan-lc-shuang-bai-po-su-jie-fa-km-tb86/">https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/575568/shua-chuan-lc-shuang-bai-po-su-jie-fa-km-tb86/</a></p><p>奇乐编程学院 <a href="https://www.bilibili.com/video/BV1AY4y157yL/?spm_id_from=333.337.search-card.all.click&vd_source=619ca0a91236fa2e514bd44a58491205">https://www.bilibili.com/video/BV1AY4y157yL/?spm_id_from=333.337.search-card.all.click&amp;vd_source=619ca0a91236fa2e514bd44a58491205</a></p></blockquote><p>KMP算法是一个快速查找匹配串的算法，作用：快速在原字符串中找到匹配字符串</p><p>在朴素解法O(m*n)的基础上将复杂度提高到仅有O(m+n)。核心：KMP算法能<strong>在[非完全匹配]的过程中提取到有效信息进行复用，以减少[重复匹配]的消耗</strong>。</p><p>朴素匹配的逻辑：将原串的指针移动到本次[发起点]的下一个位置，匹配串的指针移动到起始位置；尝试匹配，发现对不上，原串的指针会一直往后移动，直到能够与匹配串对上位置。</p><p>所以朴素匹配的复杂度是O(m*n)</p><p>KMP匹配过程：</p><p>1、匹配串检查之前已经匹配成功的部分中是否存在相同的前缀和后缀，如果存在，则跳转到前缀的下一个位置继续往下匹配</p><p>2、跳转后尝试匹配，发现两个指针的字符对不上，并且匹配串指针前面不存在相同的前缀和后缀，这时候就回到匹配串的起始位置重新开始</p><p><img src="/leetcode%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AF%87/1618755191-ddejks-image.png" alt="image.png"></p><p>KMP比朴素解法更快的原因：</p><ul><li>KMP利用已匹配部分中相同的前缀和后缀来加速下一次的匹配</li><li>KMP的原串指针不进行回溯，没有朴素匹配中回到下一个发起点的过程</li></ul><p>可以优化的部分只能是 <strong>检查已匹配部分的相同前缀和后缀</strong> 这一过程。检查前缀和后缀的目的其实是 为了确定匹配串中的下一段开始匹配的位置。</p><p><strong>对于匹配串的任意一个位置，由该位置发起的下一个匹配点位置其实与原串无关</strong>。</p><p>预处理得到next数组，数组中每个位置的值就是该下标应该跳转的目标位置（next点）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; <span class="title function_">KMP</span><span class="params">(const std::string &amp;text, const std::string &amp;pattern)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> text.size(), m = pattern.size();</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; <span class="title function_">next</span><span class="params">(m, <span class="number">0</span>)</span>;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; matches;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> next[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; pattern[i] != pattern[j])</span><br><span class="line">            j = next[j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (pattern[i] == pattern[j])</span><br><span class="line">            j++;</span><br><span class="line">        next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; text[i] != pattern[j])</span><br><span class="line">            j = next[j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (text[i] == pattern[j])</span><br><span class="line">            j++;</span><br><span class="line">        <span class="keyword">if</span> (j == m) &#123;</span><br><span class="line">            matches.push_back(i - j + <span class="number">1</span>);</span><br><span class="line">            j = next[m - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> matches;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">kmp_search</span>(<span class="params">string, patt</span>):</span><br><span class="line">    <span class="built_in">next</span> = build_next(patt) <span class="comment"># 构建next数组</span></span><br><span class="line">    </span><br><span class="line">    i = <span class="number">0</span> <span class="comment"># 主串指针</span></span><br><span class="line">    j = <span class="number">0</span> <span class="comment"># 子串指针</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(string):</span><br><span class="line">        <span class="keyword">if</span> string[i] == patt[j]: <span class="comment"># 字符匹配，指针后移</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> j &gt; <span class="number">0</span> : <span class="comment"># 字符失配，根据next跳过子串前面的一些字符</span></span><br><span class="line">            j = <span class="built_in">next</span>[j - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>: <span class="comment"># 子串第一个字符就失配</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> j == <span class="built_in">len</span>(patt): <span class="comment">#匹配成功</span></span><br><span class="line">            <span class="keyword">return</span> i - j <span class="comment"># 返回匹配的起始位置</span></span><br></pre></td></tr></table></figure><p>时间复杂度为O(n)，n代表主串的长度</p><p>next数组的构建：</p><p><img src="/leetcode%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AF%87/image-20240805183254498.png" alt="image-20240805183254498"></p><p>所以next数组的本质就是寻找子串中相同前后缀的长度，并且一定是最长的前后缀</p><p><img src="/leetcode%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AF%87/image-20240805183443824.png" alt="image-20240805183443824"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">build_next</span>(<span class="params">patt</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    计算Next数组</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">next</span> = [<span class="number">0</span>]</span><br><span class="line">    prefix_len = <span class="number">0</span> <span class="comment">#当前共同前后缀的长度</span></span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(patt):</span><br><span class="line">        <span class="keyword">if</span> patt[prefix_len] == patt[i]: <span class="comment"># 下一个字符依然相同，可以构成一个更长的前后缀</span></span><br><span class="line">            prefix_len += <span class="number">1</span></span><br><span class="line">            <span class="built_in">next</span>.append(prefix_len)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>: <span class="comment"># 下一个字符不同</span></span><br><span class="line">            <span class="keyword">if</span> prefix_len == <span class="number">0</span>: <span class="comment"># 不存在更短的前后缀</span></span><br><span class="line">                <span class="built_in">next</span>.append(<span class="number">0</span>)</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                prefix_len = <span class="built_in">next</span>[prefix_len - <span class="number">1</span>] <span class="comment"># 查看其中是否存在更短的前后缀</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">next</span></span><br></pre></td></tr></table></figure><p>计算Next数组的本质还是通过已经掌握的信息来规避重复的运算，和动态规划的思想很像</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode数组篇</title>
      <link href="/2024/03/25/LeetCode%E6%95%B0%E7%BB%84%E7%AF%87/"/>
      <url>/2024/03/25/LeetCode%E6%95%B0%E7%BB%84%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<p>本篇为Leetcode做题过程中数组篇的总结和纠错等记录。</p><p>[TOC]</p><span id="more"></span><p>分类：</p><ul><li>数组的改变、移动</li><li>数组的旋转</li><li>统计数组中的元素</li><li>数组的遍历</li><li>二维数组及滚动数组</li><li>特定顺序遍历二维数组</li><li>二维数组变换</li><li>前缀和数组</li></ul><h1 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h1><h2 id="zip"><a href="#zip" class="headerlink" title="zip()"></a>zip()</h2><p>用于数组合并。将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。注意Python3为了减少内存，返回的是一个对象，如果要展示，需手动list转换。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">b = [<span class="string">&#x27;Gary&#x27;</span>,<span class="string">&#x27;Bob&#x27;</span>,<span class="string">&#x27;judy&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">zip</span>(a,b)))</span><br><span class="line">[(<span class="number">2</span>, <span class="string">&#x27;Gary&#x27;</span>), (<span class="number">3</span>, <span class="string">&#x27;Bob&#x27;</span>), (<span class="number">4</span>, <span class="string">&#x27;judy&#x27;</span>)]</span><br></pre></td></tr></table></figure><h2 id="sorted"><a href="#sorted" class="headerlink" title="sorted()"></a>sorted()</h2><p>对所有可迭代的对象进行排序操作，sort是应用在list上的方法。list的sort方法返回的是对已经存在的列表进行操作，无返回值，而内建函数sorted返回的是一个新的list。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sorted</span>(iterable, cmp=<span class="literal">None</span>, key=<span class="literal">None</span>, reverse=<span class="literal">False</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">cmp 比较的函数，具有两个参数</span></span><br><span class="line"><span class="string">key 用来比较的元素</span></span><br><span class="line"><span class="string">reverse True降序 False升序</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="453-最小操作次数使数组元素相等（E）"><a href="#453-最小操作次数使数组元素相等（E）" class="headerlink" title="453.最小操作次数使数组元素相等（E）"></a>453.最小操作次数使数组元素相等（E）</h1><p>给你一个长度为 <code>n</code> 的整数数组，每次操作将会使 <code>n - 1</code> 个元素增加 <code>1</code> 。返回让数组所有元素相等的最小操作次数。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">只需要3次操作（注意每次操作会增加两个元素的值）：</span><br><span class="line">[1,2,3]  =&gt;  [2,3,3]  =&gt;  [3,4,3]  =&gt;  [4,4,4]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li>答案保证符合 <strong>32-bit</strong> 整数</li></ul><p>My Solution: （看了题解） —— 反向思维</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minMoves</span>(<span class="params">self, nums</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">        m = <span class="built_in">min</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="built_in">sum</span> += nums[i] - m</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span></span><br></pre></td></tr></table></figure><p>分析：n-1个数同时减一，等于有一个数自身减一。所以把每个数减到和最小的数相等即可。计算每个数和最小值的差再求和得解。</p><h1 id="283-移动零（E）"><a href="#283-移动零（E）" class="headerlink" title="283.移动零（E）"></a>283.移动零（E）</h1><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [0]</span><br><span class="line">输出: [0]</span><br></pre></td></tr></table></figure><p><strong>提示</strong>:</p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li></ul><p>My Solution: (思路正确基础上借助题解优化)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">moveZeroes</span>(<span class="params">self, nums</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(nums.count(<span class="number">0</span>)):</span><br><span class="line">            nums.remove(<span class="number">0</span>)</span><br><span class="line">            nums.append(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>借助Python的特性完成，所以非常简单，把0移除再添加即可。</p><p>题解1：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">moveZeroes</span>(<span class="params">self, nums</span>):</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">:type nums: List[int]</span></span><br><span class="line"><span class="string">:rtype: None Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="comment"># 第一次遍历的时候，j指针记录非0的个数，只要是非0的统统都赋给nums[j]</span></span><br><span class="line">j = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="built_in">len</span>(nums)):</span><br><span class="line"><span class="keyword">if</span> nums[i]:</span><br><span class="line">nums[j] = nums[i]</span><br><span class="line">j += <span class="number">1</span></span><br><span class="line"><span class="comment"># 非0元素统计完了，剩下的都是0了</span></span><br><span class="line"><span class="comment"># 所以第二次遍历把末尾的元素都赋为0即可</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(j,<span class="built_in">len</span>(nums)):</span><br><span class="line">nums[i] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># author：王尼玛</span></span><br></pre></td></tr></table></figure><p>创建两个指针，第一次遍历把非零的元素赋值到数组左边，第二次遍历把剩下的元素全赋为零即可。</p><h1 id="012-寻找数组中心下标（E）"><a href="#012-寻找数组中心下标（E）" class="headerlink" title="012.寻找数组中心下标（E）"></a>012.寻找数组中心下标（E）</h1><p>My Solution:</p><p>采用前缀和进行判断</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pivotIndex</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 前缀和</span></span><br><span class="line">        <span class="built_in">sum</span> = [<span class="number">0</span>]*<span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="built_in">sum</span>[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="built_in">sum</span>[i] = <span class="built_in">sum</span>[i-<span class="number">1</span>] + nums[i]</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">sum</span>[<span class="built_in">len</span>(nums)-<span class="number">1</span>] - <span class="built_in">sum</span>[<span class="number">0</span>] == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span>[i-<span class="number">1</span>] == <span class="built_in">sum</span>[<span class="built_in">len</span>(nums)-<span class="number">1</span>] - <span class="built_in">sum</span>[i]:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><h1 id="665-非递减数列（M）"><a href="#665-非递减数列（M）" class="headerlink" title="665.非递减数列（M）"></a>665.非递减数列（M）</h1><p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> ，请你判断在 <strong>最多</strong> 改变 <code>1</code> 个元素的情况下，该数组能否变成一个非递减数列。</p><p>我们是这样定义一个非递减数列的： 对于数组中任意的 <code>i</code> <code>(0 &lt;= i &lt;= n-2)</code>，总满足 <code>nums[i] &lt;= nums[i + 1]</code>。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [4,2,3]</span><br><span class="line">输出: true</span><br><span class="line">解释: 你可以通过把第一个 4 变成 1 来使得它成为一个非递减数列。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [4,2,1]</span><br><span class="line">输出: false</span><br><span class="line">解释: 你不能在只改变一个元素的情况下将其变为非递减数列。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 10^4</code></li><li><code>-10^5 &lt;= nums[i] &lt;= 10^5</code></li></ul><p>My Solution:（ChatGPT纠错）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">checkPossibility</span>(<span class="params">self, nums</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        nums1 = nums[:]</span><br><span class="line">        l = <span class="built_in">len</span>(nums1)</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums1[i] &gt; nums1[i + <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">if</span> count == <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">or</span> nums1[i - <span class="number">1</span>] &lt;= nums1[i + <span class="number">1</span>]:</span><br><span class="line">                    nums1[i] = nums1[i + <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    nums1[i + <span class="number">1</span>] = nums1[i]</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><blockquote><p>布尔值True和 False都要首字母大写  ^ ^</p></blockquote><p>count用来记录修改次数，在进行遍历时，判断当前元素是否大于下一个元素，如果大于就需要修改，此时count如果已经为1了，则超出了可修改的最大次数，直接返回False。如果尚未修改过一次，就根据当前元素和下一个元素的关系来进行不同的修改：</p><ul><li><p>如果当前元素是第一个元素，或者当前元素的前一个元素小于等于下一个元素，就将当前元素修改为下一个元素（以满足序列的非递减性质）</p></li><li><p>否则，将下一个元素修改为当前元素。（下一个元组比当前元素小，修改为当前元素以确保非递减性质）</p></li></ul><p>修改后要将count加1。</p><h1 id="6189-按位与最大的最长子数组（M）"><a href="#6189-按位与最大的最长子数组（M）" class="headerlink" title="6189.按位与最大的最长子数组（M）"></a>6189.按位与最大的最长子数组（M）</h1><p>给你一个长度为n的整数数组nums，考虑nums中按位与(bitwise AND)运算得到的值最大的非空子数组。返回满足要求的最长子数组的长度，数组的按位与是对数组中所有数字进行按位与运算。子数组是数组中的一个连续元素序列。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>AND的特点是1可以变成0，0可以变成1。子数组AND的结果不会超过其中任何一个元素，因此最大值就是max(num)。</p><p>实际上就是求数组中的最大值最多连续出现了几次。</p><h1 id="2420-找到所有好下标"><a href="#2420-找到所有好下标" class="headerlink" title="2420.找到所有好下标"></a>2420.找到所有好下标</h1><p>给你一个大小为n下标从0开始的整数数组nums和一个正整数k。</p><p>对于k&lt;&#x3D; i &lt;n-k之间的一个下标i，如果它满足以下条件，我们就称它为一个好下标。下标i之前的k个元素是非递增的，下标i之后的k个元素是非递减的。</p><p>按升序返回所有好下标。</p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>先倒着遍历，得到从每个位置向后的最长连续非降序列的长度，然后正着遍历，得到每个位置向前的最长连续非增序列的长度，同时统计答案。</p><h1 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39.组合总和"></a>39.组合总和</h1><p>给你一个 <strong>无重复元素</strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的 所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。</p><p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p><p>对于给定的输入，保证和为 <code>target</code> 的不同组合数少于 <code>150</code> 个。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：candidates = [2,3,6,7], target = 7</span><br><span class="line">输出：[[2,2,3],[7]]</span><br><span class="line">解释：</span><br><span class="line">2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。</span><br><span class="line">7 也是一个候选， 7 = 7 。</span><br><span class="line">仅有这两种组合。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [2,3,5], target = 8</span><br><span class="line">输出: [[2,2,2,2],[2,3,3],[3,5]]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [2], target = 1</span><br><span class="line">输出: []</span><br></pre></td></tr></table></figure><h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>可以用树形图来表示解，总和为5的所有组合再加上2，就是包含2的总和7的所有组合。</p><p>对树形图的编码通过DFS实现。</p><p><img src="/LeetCode%E6%95%B0%E7%BB%84%E7%AF%87/image-20240427165710231.png" alt="image-20240427165710231"></p><p>树的叶子结点个数就是组合种类数</p><p><a href="https://leetcode.cn/problems/combination-sum/solutions/14697/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-2/?company_slug=huawei">https://leetcode.cn/problems/combination-sum/solutions/14697/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-2/?company_slug=huawei</a></p><p>Solution1:</p><p>回溯法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combinationSum</span>(<span class="params">self, candidates: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        ans = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtracking</span>(<span class="params">index,path,target</span>):</span><br><span class="line">            <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            index: 开始下标</span></span><br><span class="line"><span class="string">            path: 所在树上路径</span></span><br><span class="line"><span class="string">            target: 需要凑成的总和</span></span><br><span class="line"><span class="string">            &quot;&quot;&quot;</span></span><br><span class="line">            <span class="keyword">if</span> index &gt;= <span class="built_in">len</span>(candidates) <span class="keyword">or</span> target &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> target == <span class="number">0</span>:</span><br><span class="line">                ans.append(path[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index, <span class="built_in">len</span>(candidates)):</span><br><span class="line">                path.append(candidates[i])</span><br><span class="line">                backtracking(i,path,target-candidates[i])</span><br><span class="line">                path.pop()</span><br><span class="line">            </span><br><span class="line">        backtracking(<span class="number">0</span>,[],target)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p>在每一次递归调用中，我们向 path 中添加一个元素，然后在递归完成后，我们需要将这个元素从 path 中移除，以确保下一次递归使用的是上一层的路径。</p><p>考虑到递归的特性，当我们从递归函数返回到上一层时，需要回到上一层的状态。如果我们不将上一层的元素从 path 中移除，那么 path 中会保留之前层级的修改，这将导致错误的结果。</p><h1 id="前缀和数组"><a href="#前缀和数组" class="headerlink" title="前缀和数组"></a>前缀和数组</h1><h2 id="1652-拆炸弹-E"><a href="#1652-拆炸弹-E" class="headerlink" title="1652.拆炸弹(E)"></a>1652.拆炸弹(E)</h2><p>你有一个炸弹需要拆除，时间紧迫！你的情报员会给你一个长度为 n 的 循环 数组 code 以及一个密钥 k 。</p><p>为了获得正确的密码，你需要替换掉每一个数字。所有数字会 同时 被替换。</p><p>如果 k &gt; 0 ，将第 i 个数字用 接下来 k 个数字之和替换。<br>如果 k &lt; 0 ，将第 i 个数字用 之前 k 个数字之和替换。<br>如果 k &#x3D;&#x3D; 0 ，将第 i 个数字用 0 替换。<br>由于 code 是循环的， code[n-1] 下一个元素是 code[0] ，且 code[0] 前一个元素是 code[n-1] 。</p><p>给你 循环 数组 code 和整数密钥 k ，请你返回解密后的结果来拆除炸弹！</p><h3 id="分析：-1"><a href="#分析：-1" class="headerlink" title="分析："></a>分析：</h3><p>code为循环数组。可以建立一个长度为2*n的前缀和数组。</p><p>如果k&lt;0，需要取位置i前的-k个数，为了防止下标越界，先将位置i往后进行n个偏移，对应区间[i+n+k, i+n-1]。(k&lt;0所以+k反而小)</p><p>k&gt;0，对应区间[i+1, i+k]</p><p>对于前缀和数组来说求和就是相减</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">self, code: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        n = <span class="built_in">len</span>(code)</span><br><span class="line">        ans = [<span class="number">0</span>] * n</span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        <span class="built_in">sum</span> = [<span class="number">0</span>] * (<span class="number">2</span>*n+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">2</span>*n+<span class="number">1</span>):</span><br><span class="line">            <span class="built_in">sum</span>[i] = <span class="built_in">sum</span>[i-<span class="number">1</span>] + code[(i-<span class="number">1</span>) % n]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> k&lt;<span class="number">0</span>:</span><br><span class="line">                ans[i-<span class="number">1</span>] = <span class="built_in">sum</span>[i+n-<span class="number">1</span>] - <span class="built_in">sum</span>[i+n+k-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans[i-<span class="number">1</span>] = <span class="built_in">sum</span>[i+k] - <span class="built_in">sum</span>[i]</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h2 id="6369-左右元素和的差值-E"><a href="#6369-左右元素和的差值-E" class="headerlink" title="6369.左右元素和的差值(E)"></a>6369.左右元素和的差值(E)</h2><p>answer[i] &#x3D; | leftSum[i] - rightSum[i] | 的简便写法：</p><p><code>[abs(x-y) for x,y in zip(leftSum, rightSum)]</code></p><h1 id="2575-找出字符串的可整除数组-M"><a href="#2575-找出字符串的可整除数组-M" class="headerlink" title="2575.找出字符串的可整除数组(M)"></a>2575.找出字符串的可整除数组(M)</h1><p>给你一个下标从 <strong>0</strong> 开始的字符串 <code>word</code> ，长度为 <code>n</code> ，由从 <code>0</code> 到 <code>9</code> 的数字组成。另给你一个正整数 <code>m</code> 。</p><p><code>word</code> 的 <strong>可整除数组</strong> <code>div</code> 是一个长度为 <code>n</code> 的整数数组，并满足：</p><ul><li>如果 <code>word[0,...,i]</code> 所表示的 <strong>数值</strong> 能被 <code>m</code> 整除，<code>div[i] = 1</code></li><li>否则，<code>div[i] = 0</code></li></ul><p>返回 <code>word</code> 的可整除数组。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：word = &quot;998244353&quot;, m = 3</span><br><span class="line">输出：[1,1,0,0,0,1,1,0,0]</span><br><span class="line">解释：仅有 4 个前缀可以被 3 整除：&quot;9&quot;、&quot;99&quot;、&quot;998244&quot; 和 &quot;9982443&quot; 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：word = &quot;1010&quot;, m = 10</span><br><span class="line">输出：[0,1,0,1]</span><br><span class="line">解释：仅有 2 个前缀可以被 10 整除：&quot;10&quot; 和 &quot;1010&quot; 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 10^5</code></li><li><code>word.length == n</code></li><li><code>word</code> 由数字 <code>0</code> 到 <code>9</code> 组成</li><li><code>1 &lt;= m &lt;= 10^9</code></li></ul><p>暴力遍历会超时。应该观察到，99取模和998取模的结果是有关系的，99可以被3整除，那么998的余数依然只和8有关系，所以可以把前缀的余数*10加上个位数字继续取模。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">divisibilityArray</span>(<span class="params">self, word: <span class="built_in">str</span>, m: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        n = <span class="built_in">len</span>(word)</span><br><span class="line">        div = []</span><br><span class="line">        x = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> word:</span><br><span class="line">            x = (x*<span class="number">10</span> + <span class="built_in">int</span>(i)) % m</span><br><span class="line">            div.append(<span class="built_in">int</span>(x==<span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> div</span><br></pre></td></tr></table></figure><h1 id="826-安排工作以达到最大收益-M"><a href="#826-安排工作以达到最大收益-M" class="headerlink" title="826.安排工作以达到最大收益(M)"></a>826.安排工作以达到最大收益(M)</h1><p>你有 <code>n</code> 个工作和 <code>m</code> 个工人。给定三个数组： <code>difficulty</code>, <code>profit</code> 和 <code>worker</code> ，其中:</p><ul><li><code>difficulty[i]</code> 表示第 <code>i</code> 个工作的难度，<code>profit[i]</code> 表示第 <code>i</code> 个工作的收益。</li><li><code>worker[i]</code> 是第 <code>i</code> 个工人的能力，即该工人只能完成难度小于等于 <code>worker[i]</code> 的工作。</li></ul><p>每个工人 <strong>最多</strong> 只能安排 <strong>一个</strong> 工作，但是一个工作可以 <strong>完成多次</strong> 。</p><ul><li>举个例子，如果 3 个工人都尝试完成一份报酬为 <code>$1</code> 的同样工作，那么总收益为 <code>$3</code> 。如果一个工人不能完成任何工作，他的收益为 <code>$0</code> 。</li></ul><p>返回 <em>在把工人分配到工作岗位后，我们所能获得的最大利润</em> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: difficulty = [2,4,6,8,10], profit = [10,20,30,40,50], worker = [4,5,6,7]</span><br><span class="line">输出: 100 </span><br><span class="line">解释: 工人被分配的工作难度是 [4,4,6,6] ，分别获得 [20,20,30,30] 的收益。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: difficulty = [85,47,57], profit = [24,66,99], worker = [40,25,25]</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>n == difficulty.length</code></li><li><code>n == profit.length</code></li><li><code>m == worker.length</code></li><li><code>1 &lt;= n, m &lt;= 104</code></li><li><code>1 &lt;= difficulty[i], profit[i], worker[i] &lt;= 105</code></li></ul><p>分析：</p><p>difficulty数组和profit数组是一一对应的，可以绑到一起。按照difficulty从小到大排序，用双指针维护工人能做的最大的profit，即为第i个工人所能获得的最大利润。累加即可得到最后的最大利润。</p><p>排序+双指针</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfitAssignment</span>(<span class="params">self, difficulty: <span class="type">List</span>[<span class="built_in">int</span>], profit: <span class="type">List</span>[<span class="built_in">int</span>], worker: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        jobs = <span class="built_in">sorted</span>(<span class="built_in">zip</span>(difficulty, profit))</span><br><span class="line">        worker.sort()</span><br><span class="line">        ans = j = max_profit = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> worker:</span><br><span class="line">            <span class="keyword">while</span> j &lt; <span class="built_in">len</span>(jobs) <span class="keyword">and</span> jobs[j][<span class="number">0</span>] &lt;= w:</span><br><span class="line">                max_profit = <span class="built_in">max</span>(max_profit, jobs[j][<span class="number">1</span>])</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            ans += max_profit</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h1 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h1><p>在删除列表元素时，会影响迭代的行为导致报错。因此要从列表末尾向前遍历，需要时删除元素。</p><p>切片：[i:] 从i开始到最后一个元素（包括i）</p><p>[:i] 从0开始到i-1（不包括i）</p><p>[1:4] 只选下标1和3的元素，不包括2</p><p>a[::-1] 取a的倒序</p><h2 id="超出时间限制"><a href="#超出时间限制" class="headerlink" title="超出时间限制"></a>超出时间限制</h2><p>字符长度为1 &lt;&#x3D; n &lt;&#x3D; 10^5，不能采用暴力枚举，否则会超时。</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>统计桌面上的不同数字</title>
      <link href="/2024/03/23/%E7%BB%9F%E8%AE%A1%E6%A1%8C%E9%9D%A2%E4%B8%8A%E7%9A%84%E4%B8%8D%E5%90%8C%E6%95%B0%E5%AD%97/"/>
      <url>/2024/03/23/%E7%BB%9F%E8%AE%A1%E6%A1%8C%E9%9D%A2%E4%B8%8A%E7%9A%84%E4%B8%8D%E5%90%8C%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<ol start="2549"><li></li></ol><p>给你一个正整数 n ，开始时，它放在桌面上。在 $10^9$ 天内，每天都要执行下述步骤：</p><p>对于出现在桌面上的每个数字 x ，找出符合 1 &lt;&#x3D; i &lt;&#x3D; n 且满足 x % i &#x3D;&#x3D; 1 的所有数字 i 。<br>然后，将这些数字放在桌面上。<br>返回在 $10^9$ 天之后，出现在桌面上的 不同 整数的数目。</p><p>注意：</p><ul><li>一旦数字放在桌面上，则会一直保留直到结束。</li><li>% 表示取余运算。例如，14 % 3 等于 2 。</li></ul><span id="more"></span><p>Own Solution:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">distinctIntegers</span>(<span class="params">self, n</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        table = [n]</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,n):</span><br><span class="line">            <span class="keyword">if</span> i-<span class="number">1</span> <span class="keyword">not</span> <span class="keyword">in</span> table:</span><br><span class="line">                table.append(n-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(table)</span><br></pre></td></tr></table></figure><p>要注意的点是特殊判断的1。<del>看了提示才做出来的^^</del>。</p><h2 id="官方解法1：模拟"><a href="#官方解法1：模拟" class="headerlink" title="官方解法1：模拟"></a>官方解法1：模拟</h2><p>用数组记录桌面上已经出现的正整数，num[n] &#x3D; 1表示桌面上只出现正整数n。每天都对桌面上已经出现的数字进行遍历，判断符合条件放到桌面上既可（令数组中该标号的数字的值为1）。最后统计num中值为1的元素数目即可。（用sum就可以了）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">distinctIntegers</span>(<span class="params">self, n</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        nums = [<span class="number">0</span>] * (n+<span class="number">1</span>)</span><br><span class="line">        nums[n] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,n):</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> nums[x] == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">if</span> x % i == <span class="number">1</span>:</span><br><span class="line">                        nums[i] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(nums)</span><br></pre></td></tr></table></figure><p>但是时间复杂度到了O($n^3$)，所以一开始想到这样判断但怕会超时就直接放弃了这种解法。</p><h2 id="官方解法2：数学"><a href="#官方解法2：数学" class="headerlink" title="官方解法2：数学"></a>官方解法2：数学</h2><p>根据题目的特殊性，10的9次方是很大的操作次数，所以可以默认一定可以将所有小于n的正整数（除了1）放到桌面上。所以除去1的特解，答案就是n-1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">distinctIntegers</span>(<span class="params">self, n</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> n == <span class="number">1</span> <span class="keyword">else</span> n - <span class="number">1</span></span><br></pre></td></tr></table></figure><blockquote><p>评论区：搞笑题。（赞成</p><p>但也算是给了一个可以走捷径的思路吧，所以记下。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>images_inserting</title>
      <link href="/2024/03/23/images-inserting/"/>
      <url>/2024/03/23/images-inserting/</url>
      
        <content type="html"><![CDATA[<p>真的很烦这个图片插入。。。</p><p><img src="/2024/03/23/images-inserting/1280px-%E6%9C%AA%E5%AE%8C%E6%88%90%E3%82%A8%E3%82%A4%E3%83%88%E3%83%93%E3%83%BC%E3%83%84.jpeg" alt="未完成エイトビーツ"></p><p>网页中是可以显示的。</p><blockquote><p>感谢：<a href="https://zhuanlan.zhihu.com/p/645679541">https://zhuanlan.zhihu.com/p/645679541</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>滚动数组</title>
      <link href="/2024/03/19/%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84/"/>
      <url>/2024/03/19/%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>在动态规划矩阵题中碰到了滑动数组的解法，能将空间复杂度从O(m n)降低到O(min(m,n))。并且不太能直观理解，故记录。</p><h2 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62.不同路径"></a>62.不同路径</h2><p>个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p><span id="more"></span><p>Solution1: 常规DP</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">uniquePaths</span>(<span class="params">self, m, n</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        dp = [[<span class="number">1</span>]*n] + [[<span class="number">1</span>] + [<span class="number">0</span>]*(n-<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m-<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i][j-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>Solution2: 用滚动数组代替二维数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">uniquePaths</span>(<span class="params">self, m, n</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        f = [<span class="number">1</span>]*n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">                f[j] += f[j-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> f[n-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>可以理解为直接在一维数组上面更新数据，原普通DP是新的数据存储在下一行的数组里，因为之前的数据其实并不影响计算结果，可以直接覆盖。</p><p>举例：</p><p>1  1  1</p><p>1  2  3</p><p>1  3  6</p><p>其实就是对上一格和左一格数据的相加。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/2024/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/2024/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​在学习计算机网络时掌握得不够好，故重新学习，偏重于理解。本文记录学习过程中的思考与理解，不涉及全部内容。</p><span id="more"></span><hr><h2 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h2><p>区分k与K，k在速率中代表10^3，K在比特中代表2^10。</p><p>在模拟信号系统中，<strong>带宽</strong>是信号的频率范围，所以单位和频率相同，包括Hz，kHz，MHz，GHz；在计算机网络中，表示通信线路的传输能力，即单位时间内通过的“最高数据率”，基本单位是b&#x2F;s，直接关系网络应用体验。</p><p>吞吐量是单位时间内通过的数据率，用于测量实际上有多少数据能够通过网络。受网络的带宽或额定速率限制。</p><p>网络时延由发送时延、传播时延、处理时延组成。</p><p>发送时延 ： 分组长度 &#x2F; 发送速率。发送速率由网卡的发送速率、信道带宽、接口速率三个指标决定，取三个量的最小值。所以应该做到各设备间以及传输介质的速率匹配，否则即使一个量再大，发送速率也并不会提高，反而会造成浪费。</p><p>传播时延 ：信道长度／电磁波传播速率。电磁波传播速率与传输介质有关，在自由空间中与光速相同。铜线2.3，光缆2。</p><p>路由器的繁忙程度是动态变化的，路由器的性能也有所不同，因此处理时延不方便计算。</p><p>发送时延和传播时延的大小关系并不绝对，应该根据情况具体分析。</p><p>时延带宽积 &#x3D; 传播时延 * 带宽。相当于以比特为单位的链路长度</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20240227205711265.png" alt="传播时延"></p><p>在许多情况下，因特网上的信息不仅仅单方向传输，而是双向交互。我们有时很需要知道双向交互一次所需的时间，因此<strong>往返时间RTT（Round-Trip Time）</strong>也是一个重要的性能指标。</p><p>是从源主机发送分组开始，直到源主机收到来自目的主机的确认分组为止，所需要的时间。</p><p>一般情况下，卫星链路的距离比较远，所带来的传播时延比较大。（相对于以太网和无线局域网）</p><p>利用率</p><p>1、信道利用率 表示某信道有百分之几的时间是被利用的（有数据通过）。</p><p>2、网络利用率 全网络的信道利用率的加权平均。 </p><p>根据排队论，当某信道的利用率增大时，该信道引起的时延也会迅速增加。因此，<strong>信道利用率并不是越高越好</strong>。当然也不能太低，否则会造成通信资源浪费。</p><p>如果用$D_0$来表示网络空闲时的时延，D表示网络当前的时延</p><p><img src="/2024/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users\86159\AppData\Roaming\Typora\typora-user-images\image-20240227210920371.png" alt="image-20240227210920371"></p><p>一些拥有较大主干网的ISP通常会控制它们的信道利用率不超过50%，如果超过了就要准备扩容，增大线路的带宽。</p><p>丢包率 即分组丢失率，是指一定时间范围内，传输过程中丢失的分组数量与总分组数量的比率。</p><p>分组丢失主要有两种情况，分组在传输过程中出现误码，被结点丢弃；分组到达一台队列已满的分组交换机时被丢弃，在通信量较大时就可能造成网络拥塞。因此，丢包率反映了网络的拥塞情况。</p><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><p>传输媒体可以分为 </p><p>导引型传输媒体（双绞线、同轴电缆、光纤、电力线）</p><p>和非导引型传输媒体（微波通信）。</p><p>物理层要解决在各种传输媒体上传输比特0和1的问题，进而给数据链路层提供<strong>透明</strong>传输比特流的服务。</p><p>物理层协议的主要任务分为 机械特性（接线器的形状尺寸、引脚数目和排列等）、电气特性（电压范围）、功能特性（电压的意义）、过程特性（各种可能事件的出现顺序）。</p><p>传输媒体种类众多，物理连接方式也很多，所以物理层协议种类就很多。每种物理层协议都包括了上述四个任务的具体内容。所以掌握物理层协议应<u>重在基本概念而不是具体协议</u>。</p><p>（传输媒体不属于计算机网络体系结构的任何一层）</p><p>同轴电缆</p><p><img src="/2024/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users\86159\AppData\Roaming\Typora\typora-user-images\image-20240228213538714.png" alt="image-20240228213538714"></p><p>分为基带同轴电缆（用于数字传输，过去用于局域网）、宽带同轴电缆（用于模拟传输，目前主要用于有线电视）</p><p>为什么不用同轴电缆—— 价格较贵且布线不够灵活和方便。在局域网领域都是用双绞线。</p><p>绞合的作用：1、抵御部分来自外界的电磁波干扰 2、减少相邻导线的电磁干扰</p><p>光纤的优点：1、通信容量大 2、传输损耗小，远距离传输时更加经济 3、电磁干扰性能好 4、无串音干扰，保密性好 5、体积小，重量轻</p><p>当光从高折射率的媒体射向低折射率的媒体时，折射角将大于入射角。因此，如果入射角足够大，就会出现全反射，光碰到包层时，就会反射回纤芯。光也就沿着光纤传输下去。</p><p>多模光纤（有多条光线同时传输）</p><p>由于色散，光在多模光纤中传输一定距离后必然产生信号失真（脉冲展宽），因此，多模光纤只适合近距离传输（建筑物内），发送光源可以用发光二极管，用光电二极管接收检测。</p><p>单模光纤：光在纤芯中一直向前传播而不发生全反射。没有脉冲展宽问题。适合长距离传输且衰减小，但制造成本高、对光源要求高，要使用激光发生器作为光源，用激光检波器作为接收检测。</p><p>波长短，穿透障碍物的能力就弱。</p><p>微波（2~40GHz）主要是直线传播。分为地面微波接力通信和卫星通信。</p><p>红外线通信属于点对点无线传输，也是直线传输，中间不能有障碍物，传输距离短。传输速率低。</p><p>LiFi 可见光通信</p><p>传输方式</p><p>串行&#x2F;并行  同步&#x2F;异步  单工&#x2F;半双工&#x2F;全双工</p><p>数据在传输线路上采用串行传输。计算机内部的数据传输常采用并行传输，例如CPU与内存通过总线传输。</p><p>实现收发双方时钟同步的方法：</p><p>1、外同步：在收发双方之间添加一条单独的时钟信号线</p><p>2、内同步：发送端将始终同步信号编码到发送数据中一起传输（如曼彻斯特编码）</p><p>异步传输：字节前后加起始位和结束位</p><p>字节之间异步（字节之间的时间间隔不固定），但字节中的每个比特仍然要同步（各比特的持续时间是相同的）</p><p><img src="/2024/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users\86159\AppData\Roaming\Typora\typora-user-images\image-20240229211936355.png" alt="image-20240229211936355"></p><p>传输媒体≠信道，传输媒体中可能有多条信道</p><p>按时钟的节拍逐个接收码元，所以需要额外一根传输线来传输时钟信号，使收发同步，但对于计算机网络，宁愿利用这根传输线传输数据信号而不是传输时钟信号。所以计算机网络中的数据传输通常不采用不归零编码这类存在同步问题的编码。而归零编码在每个码元传输结束之后信号都要归零，接收方只要在信号归零之后进行采样即可，不需要单独的时钟信号。（称为自同步）。但编码效率很低，浪费了大量数据带宽。</p><p>而曼彻斯特编码用正负跳变来表示比特1、0。传统以太网采用的就是这种编码。差分曼彻斯特编码用码元开始处电平是否发生变化表示数据，比曼彻斯特编码变化少，更适合较高的传输速率。</p><p>使用基本调制方法，1个码元只能包含1个比特信息。</p><p>因为频率和相位是相关的，频率是相位随时间的变化率，一次只能调制频率和相位两个中的一个。相位和振幅可以结合起来一起调制，称为<strong>正交振幅调制QAM</strong>。</p><p>信道的极限容量</p><p>信号波形失去了码元之间的清晰界限，这种现象叫做码间串扰。产生失真的主要原因有 码元传输速率 、 信号传输距离 、 噪声干扰、传输媒体质量</p><p><strong>奈氏准则</strong>：在假定的理想条件下，为了避免码间串扰，码元传输速率是有上限的。</p><p>注意单位</p><p><img src="/2024/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users\86159\AppData\Roaming\Typora\typora-user-images\image-20240301195433223.png" alt="image-20240301195433223"></p><p>码元传输速率又称为<strong>波特率</strong>、调制速率、波形速率或符号速率。当1个码元携带n比特的信息量时，则波特率转换为比特率时，数值要乘以n。要提高信息传输速率（比特率），就必须设法使每一个码元能携带更多个比特的信息量，这需要<u>采用多元制</u>。实际的信道所能传输的最高码元速率，要明显低于奈氏准则给出的这个上限数值。（奈氏准则是在假定的理想条件下推导出来的）</p><p><img src="/2024/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users\86159\AppData\Roaming\Typora\typora-user-images\image-20240301201447074.png" alt="image-20240301201447074"></p><p>码元携带越多的比特，并不能无限制地提高信息的传输速率，因为信道的极限信息传输速率还要受限于实际的信号在信道中传输时的信噪比。</p><p><strong>香农公式</strong>：带宽受限且<strong>有高斯白噪声干扰</strong>的信道的极限信息传输速率。（无噪声情况下不使用香农公式进行计算）</p><p><img src="/2024/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users\86159\AppData\Roaming\Typora\typora-user-images\image-20240301200046282.png" alt="image-20240301200046282"></p><p>实际能达到的传输速率比这个速率要低很多，因为还要受到脉冲干扰和衰减失真等因素的损失。从香农公式可知，信噪比和频率带宽都会影响信道数据传输速率。<u>提高信噪比</u>以提高传输速率。</p><p>调制速度就是码元传输速度。</p><p>信号传输速度不影响信道数据传输速率。</p><hr><p>接口形状属于机械特性、引脚功能属于功能特性、信号电平属于电气特性；物理地址又称硬件地址或<strong>MAC地址</strong>属于数据链路层的范畴。</p><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><p>链路（Link）就是从一个结点到相邻结点的一段物理线路，而中间没有任何其他的交换结点。</p><p>数据链路层以<strong>帧</strong>为单位传输和处理数据。</p><p>数据链路层的三个重要问题：封装成帧 、 差错检测 、 可靠传输</p><p>数据链路层给网络层交付的协议数据单元添加帧头和帧尾的操作，称为封装成帧。格式：帧尾+上层交付的数据单元+帧头</p><p>通过检错码进行差错检测。检错码封装在帧尾。</p><p>可靠传输保证了接受方还能收到因为发生了差错而被丢弃的帧的副本。即，尽管误码是不能完全避免的，但若实现发送方发送什么，接收方就能收到什么，就称为可靠传输。</p><p>注意此处讨论的都是使用点对点信道的数据链路层。</p><p>还有使用广播信道的数据链路层，帧将目的地址添加在帧中一起传输。但当总线上多条主机同时使用总线来传输帧时，传输信号就会发生碰撞。这是采用广播信道的共享式局域网不可避免的。以太网采用CSMA&#x2F;CD协议（载波监听多点接入&#x2F;碰撞检测）</p><p>交换式局域网（使用点对点链路和链路层交换机）</p><p>无线局域网仍然使用共享信道技术，802.11局域网的媒体接入控制协议CSMA&#x2F;CA（载波监听多点接入&#x2F;碰撞避免）</p><p>数据链路层概述</p><p><img src="/2024/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users\86159\AppData\Roaming\Typora\typora-user-images\image-20240304195425382.png" alt="image-20240304195425382"></p><p>接收方的数据链路层如何从物理层交付的比特流中提取出一个个的帧？实际上，帧头和帧尾的作用之一就是<strong>帧定界</strong>。但并不是每一种数据链路层协议的帧都包含有帧定界标志。例如以太网版本2的MAC帧格式</p><p><img src="/2024/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users\86159\AppData\Roaming\Typora\typora-user-images\image-20240305230606933.png" alt="image-20240305230606933"></p><p>那它的帧又是如何提取的呢？</p><p>物理层会在MAC帧前面添加8字节的前导码，前导码中的前7个字节为前同步码，作用是使接收方的时钟同步，之后的1字节为帧开始定界符。以太网还规定了帧间间隔时间，因此MAC帧并不需要帧结束定界符。</p><p>透明传输是指数据链路层对上层交付的传输数据没有任何限制，就像数据链路层不存在一样。如果不采取措施，上层交付的协议数据单元中如果出现帧定界符，则会出现误判。也就是说数据链路层要求上层的数据单元中不能包含帧定界符，这显然不符合透明传输的要求。</p><p>所以数据链路层要采取一定的措施，比如插入转义字符。如果数据中出现了转义字符，同样插入转义字符。</p><p>面向字节的物理链路使用字节填充的方法实现透明传输；</p><p>面向比特的物理链路使用比特填充的方法实现透明传输。每五个连续的比特1后面就插入一个比特0。</p><p>为了提高帧的传输效率，应当使帧的数据部分的长度尽可能大。（远大于帧头和帧尾的长度）</p><p>最大传送单元MTU（Maximum Transfer Unit）：帧的数据部分的长度上限</p><p>使用差错检测码来检测数据在传输过程中是否产生了比特差错，是数据链路层所要解决的重要问题之一。</p><p>奇偶校验：在待发送的数据后面添加1位奇偶校验位。但如果有偶数个数发生误码，则不能检查出误码（漏检）。这种方法的漏检率比较高，计算机网络的数据链路层一般不会采取这种方法。</p><p>循环冗余校验CRC</p><p><img src="/2024/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users\86159\AppData\Roaming\Typora\typora-user-images\image-20240306132530297.png" alt="image-20240306132530297"></p><p>算法要求生成多项式必须包含最低次项</p><p>检错码只能检测出帧在传输过程中出现了差错，但并不能定位错误，因此无法纠正错误。要想纠正传输中的差错，可以使用冗余信息更多的纠错码进行前向纠错。但纠错码的开销比较大，在计算机网络中较少使用。</p><p>CRC的漏检率非常低，虽然计算比较复杂，但非常易于用硬件实现，因此被广泛应用于数据链路层。</p><p>纠错常用检错重传方式，或者仅仅是丢弃，这取决于数据链路层向上层提供的是否是可靠传输服务。</p><p>一般情况下，有线链路的误码率比较低， 为了减小开销，不要求数据链路层向上提供可靠传输服务。无线链路则要求必须提供可靠传输服务。</p><p>传输差错包括 比特差错、分组丢失、分组失序、分组重复。</p><p>分组失序：最先发送的分组未必最先到达。分组丢失、分组失序以及分组重复这些传输差错一般不会出现在数据链路层，而会出现在其上层。因此，可靠传输服务不仅仅局限于数据链路层。——学习可靠传输机制时不应该把思维局限在数据链路层。</p><p>IP向上层提供的是无连接、不可靠的传输服务。TCP向上层提供面向连接的可靠传输服务。UDP向上层提供无连接、不可靠传输服务。</p><p>需要注意的是，可靠传输服务开销比较大，要根据应用需求来取舍。</p><h3 id="停止等待协议SW（Stop-and-Wait）"><a href="#停止等待协议SW（Stop-and-Wait）" class="headerlink" title="停止等待协议SW（Stop-and-Wait）"></a>停止等待协议SW（Stop-and-Wait）</h3><p>如果数据在传输过程中丢失了，发送方将一直处于等待接收方发送的状态。因此需要设置一个超时计时器。（超时重传）一般将重传事件选为略大于从发送方到接收方的平均往返时间。（在运输层，由于端到端往返时间非常不确定，设置合适的重传时间有时并不容易）</p><p>接收端检测到数据分组有误码时，将其丢弃并等待发送方的超时重传，但对于误码率较高的点对点链路，为使发送方尽早重传，也可给发送方发送NAK分组。</p><p>还要考虑到接收方发送的确认或否认分组丢失的情况，此时会超时重传，但接收方之前已经收到了这个数据分组，所以需要判断是新的分组还是重复的分组。为了避免分组重复的传输错误，必须给每个分组<strong>加上序号</strong>。对于停止等待协议，每次只发送一个分组就停止等待，因此只要保证与上次发送的分组序号不同就可以了，因此只需要用一个比特来编号。</p><p>如果收到了重复的分组，接收方就丢弃这个分组，重新发一次ACK。同样的，为了保证应答与数据分组的一一匹配，确认分组也需要编号。</p><p>特别地，对于数据链路层的点对点信道，往返时间比较固定，不会出现确认迟到的情况，如果只在数据链路层，可以不用给确认分组编号。</p><p><img src="/2024/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users\86159\AppData\Roaming\Typora\typora-user-images\image-20240307104826674.png" alt="image-20240307104826674"></p><p>当往返时延RTT远大于数据帧发送时延$T_D$​时（例如卫星链路），信道利用率非常低。若出现重传，则对于传送有用的数据信息来说，信道利用率还要降低。（所以停止-等待协议信道利用率很低）</p><p>像停止 -等待协议这种通过确认和重传机制实现的可靠传输协议，常称为<strong>自动请求重传协议ARQ</strong>（Automatic Repeat reQuest）</p><h3 id="回退N帧协议GBN"><a href="#回退N帧协议GBN" class="headerlink" title="回退N帧协议GBN"></a>回退N帧协议GBN</h3><p> 流水线传输可提高信道利用率。  发送方每接收一个确认分组，发送窗口就向前移动一个位置。</p><p>累积确认 ： 接收方不一定要对收到的数据分组逐个发送确认，而是可以在收到几个数据分组后，对按序到达的最后一个数据分组发送确认。ACKn表示序号为n及以前的所有数据分组都已成功接收。 —— 好处：即使确认分组丢失，发送方也可能无需重传；可以减小接收方的开销，减小对网络资源的占用。</p><p>考虑传输过程中出现差错的情况，发送方收到重复的确认，就知道之前发送的分组出现了差错，于是可以不等超时计时器超时就立刻重传。决定重传的重复确认数量由具体实现决定。</p><p>如果5号分组误码不被接收，那么即使序号为6，7，0，1的分组正确到达，接收方因为接收窗口不匹配也不会接受它们，发送方仍然要重传它们。这就是所谓的回退N帧(Go-Back-N)</p><p>因此，当信道质量不好时，回退N帧协议的信道利用率并不比停止-等待协议高。</p><p>如果序号采用n个比特，那么发送方的窗口长度最大为$2^n-1$​，如果超过这个范围，接收方将无法分辨新、旧数据分组，也就是分组重复。</p><p>接收方的接收窗口尺寸只能为1，因此接收方只能按序接收数据分组，且只接收序号落在接收窗口内且无误码的数据分组。</p><p><img src="/2024/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users\86159\AppData\Roaming\Typora\typora-user-images\image-20240311220404971.png" alt="image-20240311220404971"></p><p>为了进一步提高性能，可设法只重传出现误码的数据分组，因此接收窗口的尺寸应该扩大，以便接收方能收下失序到达但无误码的数据分组。—— 选择重传协议</p><h3 id="选择重传协议"><a href="#选择重传协议" class="headerlink" title="选择重传协议"></a>选择重传协议</h3><p>不能采用累积确认，需要进行逐一确认。发送窗口的尺寸问题和回退N是一样的。只有在按序接收数据分组后，接收窗口才能滑动，但是可以先接收乱序的分组。</p><p>PPP协议</p><p>为点对点协议。链路控制协议LCP用于建立、配置以及测试数据链路的连接。</p><p><img src="/2024/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users\86159\AppData\Roaming\Typora\typora-user-images\image-20240315213302350.png" alt="image-20240315213302350"></p><p>差错监测：循环冗余校验CRC。如果检验不正确就丢弃该帧。使用PPP的数据链路层向上不提供可靠传输服务。</p><p><img src="/2024/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users\86159\AppData\Roaming\Typora\typora-user-images\image-20240315213700082.png" alt="image-20240315213700082"></p><p>媒体接入控制（Medium Access Control）</p><p>​即如何协调多个发送和接收站点对一个共享传输媒体的占用。<u>媒体接入控制可以分为静态划分信道和动态接入控制</u>。</p><p>​静态划分信道就是预先固定分配好信道，这对于突发性数据传输信道利用率会很低，通常在无线网络的物理层中使用，而不是在数据链路层中使用。可以分为频分多址、时分多址、码分多址。</p><p>​动态接入控制可以分为受控接入和随机接入，受控接入又分为集中控制和分散控制。在<strong>集中控制</strong>的多点轮询协议中，有一个主站以循环方式轮询每个站点有无数据发送，只有被轮询到的站点才能发送数据，最大缺点是单点故障问题。  在分散控制的令牌传递协议中，各站点是平等的，连接成一个环形网络，令牌沿环逐站传递。采用令牌传递协议的典型网络有 IEEE 802.5 令牌环网；IEEE 802.4 令牌总线网；光纤分布式数据接口FDDI。（但都已经被淘汰了）</p><p>​随机接入的特点是所有站点通过竞争、随机在信道上发送数据。要解决的关键问题是尽量避免冲突以及在发送冲突后如何尽快恢复通信。共享式以太网采用的就是随机接入。</p><p>​具有更高性能的使用点对点链路和链路层交换机的交换式局域网在有线领域已完全取代了共享式局域网，但由于无线信道的广播天性，无线局域网使用的还是共享媒体技术。</p><p>码分复用CDM是一种共享信道的方法。该技术主要用于多址接入，更常用的名词是码分多址<strong>CDMA</strong>（Code Division Multiple Access）</p><blockquote><p>此处不严格区分复用和多址。复用是将单一的媒体的频带资源划分为很多子信道，之间相互独立互不干扰。从媒体的整体频带资源上看，每个子信道只占用该媒体频带资源的一部分。</p><p>多址（多点接入）处理的是动态分配信道给用户，这在用户仅仅暂时性地占用的应用中是必须的，而所有的移动通信系统基本上都属于这种情况。所以信道永久性地分配给用户的应用不需要多址。</p></blockquote><p>CDM的每一个用户可以在同样的时间使用同样的频带进行通信，由于各用户使用不同码型，相互之间不会干扰。</p><p>在CDMA中，每一个比特时间再划分为m个短的间隔，称为码片（Chip），通常取64或128。每个站指派一个唯一的码片序列。对每个站的码片序列的要求：1、必须各不相同，实际上常用伪随机码序列；2、必须相互正交（规格化内积为0）</p><p>直接序列扩频DSSS：</p><p><img src="/2024/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users\86159\AppData\Roaming\Typora\typora-user-images\image-20240316210209794.png" alt="image-20240316210209794"></p><p><img src="/2024/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users\86159\AppData\Roaming\Typora\typora-user-images\image-20240316210539402.png" alt="image-20240316210539402"></p><p>载波监听多址接入&#x2F;碰撞检测 CSMA&#x2F;CD（Carrier Sense Multiple Access&#x2F;Collision Detection）</p><p>以太网会采取强化碰撞</p><p><img src="/./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20240319163242902.png" alt="image-20240319163242902"></p><p>以太网的最小帧长确保了主机可在帧发送完成之前就检测到该帧的发送过程中是否遭遇了碰撞。凡长度小于64字节的帧都是由于碰撞而异常终止的无效帧。</p><p>无线局域网使用CSMA&#x2F;CA协议，即载波监听多址接入&#x2F;碰撞避免（Carrier Sense Multiple Access&#x2F;Collision Avoidance）。因为在无线局域网中不能使用碰撞检测CD，对硬件要求非常高（无线信道的传输条件特殊，信号强度的动态范围非常大）。并且无线传播存在隐藏站点的问题（不能检测出信道上其他站点的信号），进行碰撞检测的意义也不大。</p><p>因此802.11无线局域网使用CSMA&#x2F;CA协议。具体实现：1、<strong>帧间间隔IFS</strong>（InterFrame Spcae)。所有站点必须在持续检测到信道空闲帧间间隔长之后才能发送帧。常用的两种帧间间隔有SIFS（短）、DIFS（在DCF方式中）。</p><p>工作流程：源站有数据要发送，检测到信道是空闲的，等待帧间间隔DIFS后发送数据帧。（为了等待更高优先级的帧是否要发送）。目的站接收到帧后，等待帧间间隔SIFS后发送ACK。（SIFS是最短的帧间间隔，用来分隔开属于一次对话的各帧。在这段时间内，一个站点应当能够从发送方式切换到接收方式）。当信道从忙状态转换到空闲状态，并经过帧间间隔DIFS后，需要退避一段随机时间后才能发送（防止多个站点同时发送数据而产生碰撞） 。</p><p>但退避算法不是必须的。必须使用退避算法的情况：1、在发送数据帧之前检测到信道处于忙状态时 2、每一次重传一个数据帧时 3、在每一次成功发送后要连续发送下一个帧时（为了避免一个站点长时间占用信道）</p><p><img src="/./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20240323155549763.png" alt="image-20240323155549763"></p><h4 id="CSMA-CA协议的信道预约和虚拟载波监听"><a href="#CSMA-CA协议的信道预约和虚拟载波监听" class="headerlink" title="CSMA&#x2F;CA协议的信道预约和虚拟载波监听"></a>CSMA&#x2F;CA协议的信道预约和虚拟载波监听</h4><p>为了尽可能减少碰撞的概率和降低碰撞的影响，802.11标准允许要发送数据的站点对信道进行预约。源站在发送数据帧之前先发送一个短的控制帧，称为请求发送RTS（Request To Send）。如果目的站可以接收，就发送一个相应控制帧，称为允许发送CTS（Clear To Send）。除源站和目的站以外的其他各站，在收到CTS帧后就推迟接入到无线局域网中，保证源站和目的站之间的通信不会受其他站的干扰。如果RTS帧发生碰撞，需要执行退避算法重传。</p><p>因为RTS帧和CTS帧很短，发生碰撞的概率、碰撞产生的开销及本身的开销都很小。因此用很小的代价对信道进行预约往往是值得的。802.11标准规定了可选的三种情况：1、使用RTS帧和CTS帧 2、不使用RTS帧和CTS帧 3、只有当数据帧的长度超过某一数值时才使用RTS帧和CTS帧。</p><p>虚拟载波监听机制：数据帧也能携带通信需要的持续时间。站点只要监听到RTS帧、CTS帧或数据帧中的任何一个，就能知道信道被占用的持续时间，而不需要真正监听到信道上的信号，因此虚拟载波监听机制能减少隐藏站点带来的碰撞问题。</p><blockquote><p>CDMA是码分多址，是物理层的信道复用技术，不属于MAC协议。CSMA和CSMA&#x2F;CD都不使用确认机制，CSMA&#x2F;CA在无线信道中使用，因为无线信道的通信质量远不如有线信道，因此需要使用确认机制。</p><p>CSMA属于争用型的媒体接入控制协议。</p></blockquote><h2 id="集线器与交换机的区别"><a href="#集线器与交换机的区别" class="headerlink" title="集线器与交换机的区别"></a>集线器与交换机的区别</h2><ul><li>使用集线器的以太网在逻辑上还是总线网，各站共享总线资源，使用的还是CSMA&#x2F;CD协议。</li><li>集线器只工作在物理层，每个接口仅仅简单地转发比特，不进行碰撞检测。</li><li>集线器一般都有少量的容错能力和网络管理功能，可以断开与故障网卡的连线，使整个以太网仍然正常工作。</li></ul><p>使用集线器在物理层扩展以太网。</p><p>前提：忽略ARP过程并假设交换机的帧交换表已经配置好了。</p><ul><li>以太网交换机通常都有多个接口，每个接口都可以直接与一台主机或另一个以太网交换机相连，一般都工作在全双工方式。（集线器以太网在逻辑上是共享总线的，需要使用CSMA&#x2F;CD协议来协调各主机争用总线，只能工作在半双工模式）</li><li>以太网交换机具有并行性，能同时连通多对接口，使多对主机能同时通信，无碰撞（不使用CSMA&#x2F;CD协议）</li><li>以太网交换机工作在数据链路层（也包括物理层），它收到帧后，在帧交换表中查找帧的目的MAC地址所对应的接口号，然后从该接口转发帧。</li><li>以太网交换机是一种即插即用的设备，帧交换表是通过自学习算法自动建立起来的。</li><li>许多以太网交换机都采用存储转发方式来转发帧。</li></ul><p>交换机可以隔离碰撞域而集线器不可以。</p><h2 id="TCP和UDP的对比"><a href="#TCP和UDP的对比" class="headerlink" title="TCP和UDP的对比"></a>TCP和UDP的对比</h2><p>是TCP&#x2F;IP体系结构<strong>传输层</strong>中的两个重要协议。使用频次仅次于网络层的IP协议。</p><p>UDP(User Datagram Protocol)用户数据报协议</p><p>TCP(Transmission Control Protocol) 传输控制协议</p><ul><li><p>UDP是无连接的，TCP是面向连接的。</p></li><li><p>UDP支持单播、多播、广播（一对一，一对多，一对全）。TCP因为要建立一对一的信道，仅支持单播。</p></li><li><p>UDP对应用进程交下来的报文既不合并也不拆分，直接添加一个UDP首部，使之成为UDP用户数据报。也就是说，UDP是面向应用报文的。</p></li></ul><p>TCP把应用进程交付下来的数据块仅仅视作一连串无结构的字节流，TCP并不知道这些待传送的字节流的含义，编号存储在自己的发送缓存中。根据发送策略，从发送缓存中提取一定数量的字节，构建TCP报文段并发送，接收方的TCP一方面从所接收到的TCP报文段中取出数据载荷部分并存储在接收缓存中，一方面将接收缓存中的一些字节交付给应用进程。接收方的应用进程必须有能力识别收到的字节流，还原成有意义的应用层数据。<strong>TCP是面向字节流的。这正是TCP实现可靠传输、流量控制以及拥塞控制的基础</strong>。（TCP是全双工的）</p><ul><li>UDP向上层提供的是无连接不可靠传输服务，对于UDP用户数据包出现的误码和丢失等问题，UDP并不关心。</li></ul><p>因此，UDP适用于实时应用，例如IP电话、视频会议等。</p><p>尽管IP协议向上层提供的是无连接不可靠的传输服务，即IP数据报可能在传输过程中出现丢失或误码，但只要传输层使用TCP协议，就可向上层提供面向连接可靠传输服务。</p><p>因此，TCP适用于要求可靠传输的应用，例如文件传输。</p><ul><li>一个UDP用户数据报由首部和数据载荷两部分构成。首部非常简单，仅有8个字节。</li></ul><p>TCP报文段也由首部和数据部分构成，但首部要复杂得多，最小为20字节。</p>]]></content>
      
      
      <categories>
          
          <category> 基础课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>留学面试经验</title>
      <link href="/2023/12/09/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/"/>
      <url>/2023/12/09/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h1><p>常见的开场问题，用于了解基本信息和表达能力。</p><p>在一分钟内表达清楚、简洁、自信是关键，确保突出学术和职业素养，同时展示你对留学的热忱和对目标学校的兴趣。流畅自然会加印象分。</p><span id="more"></span><p>学习&#x2F;工作&#x2F;生活中的细节</p><p>申请学校&#x2F;专业的原因</p><p>兴趣爱好</p><p>优势&#x2F;强项&#x2F;成绩</p><p>展现个性的事例</p><h1 id="提问"><a href="#提问" class="headerlink" title="提问"></a>提问</h1><p>1、 <strong>为什么选择这个专业&#x2F;领域？</strong></p><p>2、<strong>为什么选择我们学校&#x2F;项目？</strong></p><p>3、<strong>你过去的学术或工作经历对你为留学做好准备吗？</strong></p><p>4、<strong>你在之前的研究&#x2F;工作中取得了哪些成就？</strong></p><p>评估能力和经验</p><p>5、<strong>你是如何解决困难或挑战的？</strong></p><p>适应能力和解决问题的能力</p><p>6、<strong>你对未来有什么规划？</strong></p><p>未来职业目标和如何将留学经验融入其中</p><p>7、<strong>特殊的兴趣或研究方向</strong></p><p>8、<strong>你如何看待多元文化环境和国际交流？</strong></p><p>9、<strong>你有哪些特殊的技能或爱好？</strong></p><blockquote><p>我认识到在国外学习会带来一些学业和生活方面的挑战，但我有信心能够有效地应对这些压力。首先，我计划建立良好的学业规划和时间管理习惯。我将制定详细的学习计划，确保我能够合理分配时间，有效地完成学术任务。同时，我明白保持良好的工作与休息平衡对于长期的学业表现至关重要，因此我会定期进行休息和娱乐活动，以确保自己保持健康的身心状态。</p><p>其次，我打算积极融入当地社区，与同学和当地人建立联系。这将有助于我更快地适应新的文化和生活方式，同时也提供了一个支持系统，可以在面对挑战时相互支持。我相信在一个支持性的社交网络中，我能够更好地处理学业压力和生活挑战。</p><p>此外，我会不断寻求帮助和反馈。如果我在学术方面遇到困难，我将主动寻求导师和同学的帮助。在生活方面，我将寻找校园资源和当地社区服务，以便更好地解决生活中的各种问题。</p><p>总体而言，我对于适应新的学术和生活环境有着积极的态度，并且我将灵活应对各种挑战。我相信这种积极主动的态度，以及我在解决问题和管理压力方面的经验，将有助于我在国外学习期间取得成功。</p></blockquote><blockquote><p>除了追求学历深造，我对在国外学习有许多其他期望和目标。首先，我视这段留学经历为一个全面提升个人素养和技能的机会。我希望通过与国际上优秀的学者和同学交流，不仅在专业领域取得更深层次的理解，同时也在思维方式、创新能力等方面得到提升。</p><p>其次，我渴望全面融入新的文化和社交圈。在国外学习，我将有机会接触到不同背景和文化的人，这对我来说是一次拓展视野、提高跨文化交际能力的绝佳机会。我希望通过积极参与学术和社交活动，建立起广泛的人际关系网络，不仅有助于学业上的合作，还能够为未来的职业发展奠定基础。</p><p>此外，我还认为在国外学习是一个挑战自我的过程，我期待在面对新环境、新问题时培养更强的适应能力和解决问题的能力。我相信这种挑战将使我更加成熟，更具韧性，为未来职业生涯打下坚实的基础。</p><p>总的来说，我不仅将专注于学术层面的提升，同时也将全身心投入到丰富多彩的留学生活中，以达到在多个方面全面发展的目标。”</p></blockquote><p>主要分为：自我介绍 - 动机 - 个人优势和经验 - 未来规划四个维度。</p><p>在表达时尽量保持真诚和自然，并且适当地结合个人经历和情境，会使表达更加个性化。</p><h1 id="港大面试准备"><a href="#港大面试准备" class="headerlink" title="港大面试准备"></a>港大面试准备</h1><h3 id="Self-Introduction-1-min"><a href="#Self-Introduction-1-min" class="headerlink" title="Self-Introduction(1 min)"></a>Self-Introduction(1 min)</h3><blockquote><p>Good afternoon, my name is Liu Yonghe and I’m majoring in the Internet of Things Engineering in University of Electronic Science Technology of China.  I have deep interest in computer science so I try to change my direction to cs in master period. And I also take actions like trying to find a internship and doing projects in web development. I have also learned most courses concerning cs. But I am longing for finding more possibility in cs and the MSc programme is a ideal choice because it offers diverse courses and opportunities.  </p></blockquote><blockquote><p>Good afternoon, my name is Liu Yonghe. I am majoring in Internet of Things Engineering at the University of Electronic Science and Technology of China. My passion for computer science has driven me to shift my focus to this field for my master’s degree.</p><p>I have completed relevant computer science courses, engaged in projects, and tried for internships to gain practical experience. One notable project involved developing a web application for IoT devices, which reinforced my technical and problem-solving skills.</p><p>I believe the MSc program at the University of Hong Kong is ideal for me due to its diverse courses and opportunities. I am excited about the chance to advance my knowledge and contribute to this vibrant academic community.</p><p>Thank you.</p></blockquote><h2 id="Why-HKU"><a href="#Why-HKU" class="headerlink" title="Why HKU"></a>Why HKU</h2><blockquote><p>Example:</p><p>I have chosen the University of Hong Kong because of its outstanding reputation in academic excellence and research innovation. The university’s diverse and inclusive environment is very appealing, and I believe it will provide a rich cultural experience. Additionally, the strong network and opportunities or internships and collaborations with leading organizations in Hong Kong make it an ideal place to advance my education and career aspirations.</p></blockquote><h2 id="Why-Programme"><a href="#Why-Programme" class="headerlink" title="Why Programme"></a>Why Programme</h2><blockquote><p>I think the programme is a very good opportunity for me to shift my major direction and   I remember the slogan “Our programme trains students professional skills; emphasizes on hands-on ability”. I admire this idea and it accords with my career plan.</p></blockquote><h2 id="Coding"><a href="#Coding" class="headerlink" title="Coding"></a>Coding</h2><p>前缀和 prefix sum</p><p>小数,十进制 decimal</p><p>八进制 octal</p><p>十六进制 hexadecimal</p><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><p><a href="https://www.learncpp.com/">https://www.learncpp.com</a></p><p>指令 instruction</p><p>语句 statements</p><p>declaration statements &#x2F; jump statements&#x2F; expression statements &#x2F; compound statements &#x2F; selection statements(conditionals) &#x2F; iteration statements(loops) &#x2F; try blocks</p><p>nomenclature 命名法</p><p>shorthand 简写</p><p>parenthesis 括号 curly brace 大括号</p><p>term 术语</p><p>differentiate 区分</p><p>标识符 identifier</p><p>preprocessor directive 预编译指令</p><p>console 控制台</p><p>编译 compile 编译器 compiler</p><p>execute 执行</p><p>operator 符号</p><p>general template or variation on it 通用模板或变体</p><p>syntax and syntax errors 语法和语法错误</p><p>semicolon 分号</p><blockquote><p>A statement is an instruction in a computer program that tells the computer to perform an action.</p><p>A function is a collection of statements that executes sequentially.</p><p>A syntax error is  a compiler error that occurs at compiler-time when your program violates the grammar rules of the C++ language.</p><p>A library file is a collection of precompiled code that has been “packaged up” for reuse in other programs. The C++ Standard Library is a library that ships with C++. It contains additional functionality to use in your programs.</p></blockquote><p>a library that ships with C++  C++附带的库</p><p>comments 注释</p><p>single-line comments 单行注释 Multi-line comments 多行注释</p><p>align 对齐</p><p>nest 嵌套  Multi-line style comments can not be nested.</p><p>wrap 封装</p><blockquote><p>Comments should be used to describe <strong>why</strong> the code is doing something. A bad statement comment explains what the code is doing.</p><p>Programmers often have to make a tough decision between solving a problem one way, or solving it another way. Comments are a great way to remind yourself(or tell somebody else) the reason you made one decision instead of another.</p><p>Reading individual lines of code is easy. Understanding what goal they are meant to accomplish is not.</p></blockquote><p>manipulate 操纵，操作</p><blockquote><p>Programs are collections of instructions that manipulate data to produce a desired result.</p></blockquote><h2 id="数据库-Database"><a href="#数据库-Database" class="headerlink" title="数据库 Database"></a>数据库 Database</h2><p>关系代数 The Relational Algebra</p><p>模式 schema</p><p>查询语言 Query Languages</p><p>事务 transaction</p><p>四大范式 four normal forms(1NF 2NF 3NF BCNF)</p><p>used in database normalization theory to structure relational databases efficiently and avoid data redundancy and inconsistency.</p><h2 id="Probability-Theory"><a href="#Probability-Theory" class="headerlink" title="Probability Theory"></a>Probability Theory</h2><p>random variable 随机变量</p><p>probability distribution 概率分布</p><p>expected value 期望值</p><p>mean 均值 </p><p>variance 方差</p><p>standard deviation 标准差</p><p>independent events 独立事件</p><p>conditional probability 条件概率 (of A give B)</p><p>Bayes’ Theorem 贝叶斯定理</p><h2 id="Number-Theory"><a href="#Number-Theory" class="headerlink" title="Number Theory"></a>Number Theory</h2><p>六人集会问题</p><p>Use six point to represent six person. Consider two person, if they know each other, then we can draw a red line between the two points representing them. Otherwise draw a blue line. According to Pigeonhole Theory, use two colors to draw five lines, there are at least three lines in the same color. So we can suppose that AB,AC,AD are red. Then if any one of BC,BD,CD is red, we can get a red triangle. That means at least three people know each other. Otherwise, the three lines are all blue, they don’t know each other. In any case, it’s consistent with the conclusion of the problem.</p><h2 id="Calculus"><a href="#Calculus" class="headerlink" title="Calculus"></a>Calculus</h2><p>分子 numerator</p><p>分母 denominator</p><p>积分 integral</p><p>微分 differential</p><p>导数 derivative</p><p>指数 exponent</p><p>幂 power</p><p>分部积分法 integration by parts</p><p>换元 substitution</p><h2 id="Linear-Algebra"><a href="#Linear-Algebra" class="headerlink" title="Linear Algebra"></a>Linear Algebra</h2><p>行列式 determinant</p><p>秩 rank</p><p>组合 combination</p><p>排列 arrangement</p><p>等价矩阵 equivalent matrices</p><h2 id="反问"><a href="#反问" class="headerlink" title="反问"></a>反问</h2><p>是否有实习机会</p><h2 id="参考面经"><a href="#参考面经" class="headerlink" title="参考面经"></a>参考面经</h2><p>1、思考并回答大学生是否应该使用chatGPT？（主要考察口语和逻辑）</p><blockquote><p>Yes. Students can benefit from using chatGPT as a valuable tool for several reasons:</p><p>First, ChatGPT can help students understand complex topics, assist with homework , and provide explanations for difficult concepts.</p><p>Second, ChatGPT can be a conversation partner to practice and improve their language skills.</p><p>It can also offer some other help. However, students should use it responsibly, ensuring they understand the material themselves and not rely solely on it for academic work.</p></blockquote><p>2、重做笔试题</p><p>Write a program in any of the following programming languages: C, C++, python, or  Java. The program should take a decimal integer as input and display its binary representation. For example, if the input is 12, then the program should print 1100.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bin</span>(n)[<span class="number">2</span>:])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ans = []</span><br><span class="line"><span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">    ans.append(n % <span class="number">2</span>)</span><br><span class="line">    n //= <span class="number">2</span></span><br><span class="line">ans.reverse()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, ans)))</span><br></pre></td></tr></table></figure><p>More consideration Version(with input and output hints)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">decimal_to_binary</span>(<span class="params">decimal_number</span>):</span><br><span class="line">    <span class="keyword">if</span> decimal_number &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Invalid input. Please enter a non-negative integer.&quot;</span></span><br><span class="line">    </span><br><span class="line">    binary_representation = <span class="built_in">bin</span>(decimal_number)[<span class="number">2</span>:]</span><br><span class="line">    <span class="keyword">return</span> binary_representation</span><br><span class="line"></span><br><span class="line">decimal_number = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter a decimal integer: &quot;</span>))</span><br><span class="line"></span><br><span class="line">binary_representation = decimal_to_binary(decimal_number)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(binary_representation)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3、反问</p><p>1、对于笔试的感觉</p><p>2、介绍自己最闪光的地方</p><p>3、学过什么编程语言，面向对象编程的特点(properties)有哪些</p><p>encapsulation </p><blockquote><p>A method of hiding the implementation details of an abstract functional interface</p></blockquote><p>inheritance</p><blockquote><p>to give an object of one type the characteristics of an object of another type</p></blockquote><p>polymorphism</p><blockquote><p>The ability of the same action to have multiple different manifestations or forms</p></blockquote><p>4、历史上第一个面向对象的编程语言是什么</p><p>SIMULA</p><p>5、对于HKU MsC的疑问</p><p>Part 1:</p><p>Why program</p><p>why school</p><p>why hk</p><p>本科喜欢的一门课</p><p>职业规划</p><p>硕士喜欢的课</p><p>项目经验</p><p>Part 2:</p><p>图像的编码方式，具体是怎么编码的</p><p>… media相关的</p><p>Please introduce your academic background and your learning experiences related to Computer Science.</p><p>Why are you interested in Computer Science? Were there any specific experiences or reasons that motivated you to pursue a degree in this field?</p><p>Share a research topic that you consider to be the most important or exciting in the field of Computer Science and explain why you are interested in it.</p><h2 id="review"><a href="#review" class="headerlink" title="review"></a>review</h2><p>余数</p><p>商</p><p>分子</p><p>分母</p><p>八进制</p><p>十六进制</p><p>微分</p><p>指数</p><p>幂</p><p>有理数</p><p>质数</p><p>倒数</p><p>行列式</p><p>数学归纳法</p><p>换元</p><p>声明 </p><p>顺序表</p><p>递归</p><h2 id="项目经历"><a href="#项目经历" class="headerlink" title="项目经历"></a>项目经历</h2><p>I have developed a web application for IoT devices. It is based on springboot, vue frame and MySQL. It includes the arrangement of database, the design of the web like paging and page routing to complete a entire system.  </p>]]></content>
      
      
      <categories>
          
          <category> 经验谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 留学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python数据挖掘</title>
      <link href="/2023/10/26/Python%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
      <url>/2023/10/26/Python%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>数据挖掘（Data Mining）就是从大量不完整、有噪声、模糊、随机的实际应用数据中，提取隐含在其中、人们事先不知道、但是又潜在有用的信息和知识的过程。</p><p>实际上是一个决策支持过程，对数据进行高度自动化的分析从而做出归纳性推理，从中挖掘出潜在的模式，辅助决策者调整策略、减少风险、做出正确的决策。</p><span id="more"></span><p>数据挖掘有别于数据分析，数据分析是人为驱动的，数据挖掘是数据驱动的。</p><p>Ex.垃圾邮件的判断和筛选</p><p>​数据分析方法需要针对邮件的发送人、标题、关键字等因素进行分析，如果含有违法违规信息则判定为垃圾邮件；</p><p>​数据挖掘方法只需要把标注是否是垃圾邮件的数据交给模型学习，训练成功后就可以用来自动识别垃圾邮件。</p><p>Python语言语法清晰、逻辑性强、易读性高，且初始安装环境就已经附带许多高级数据类型，便于操作。</p><h1 id="一般流程"><a href="#一般流程" class="headerlink" title="一般流程"></a>一般流程</h1><p>（一）数据读取</p><ul><li>读取数据，进行展示</li><li>统计数据各项指标</li><li>明确数据规模和要完成的任务</li></ul><p>（二）特征理解分析</p><ul><li>单特征分析，逐个变量分析其对结果的影响</li><li>多变量统计分析，综合考虑多种情况影响</li><li>统计绘图得出结论</li></ul><p>（三）数据清洗与预处理</p><ul><li>对缺失值进行填充</li><li>特征标准化&#x2F;归一化</li><li>筛选有价值的特征</li><li>分析特征之间的相关性</li></ul><p>（四）建立模型</p><ul><li>特征数据与标签准备</li><li>数据集切分</li><li>多种建模算法对比</li><li>集成策略等方案改进</li></ul><h1 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h1><ul><li><p>分类</p><p>找出样本数据集的共同特征，将数据集划分为不同的类型。</p><p>目的：寻找重要变量因素、了解族群特征或建立分类规则。</p><p>应用：商品分类、垃圾邮件过滤、新闻分类、智能推荐等。</p><p>常用算法：决策树、朴素贝叶斯、K近邻和支持向量机。</p></li><li><p>回归</p><p>输入数据往往为数值型。</p><p>目的是预测输入内容的数值，或者说找到一条尽可能接近数据集的各个点的最优拟合线。</p><p>应用：预测销售趋势、房价变动、产品生命周期分析、股市成交额及天气状况。</p></li><li><p>关联</p><p>又称关联规则挖掘。在大规模数据集中寻找数据之间关系的算法。</p><p>目的：发现频繁项集，从频繁项集中发现关联规则。关联规则反映了物品和其他物品之间的关联性。即给定一组事务，根据事务中物品项的出现情况预测物品项出现的规则。</p><p>应用：预测客户需求、关联推荐营销、客户交叉营销、风险防范等。</p><p>常用算法：Apriori、FP-Growth</p></li><li><p>聚类</p><p>不给定数据特征种类，根据数据间相似度进行数据集簇，使得簇内距离最小化、簇间距离最大化的分析方法。</p><p>应用：根据一些特定的症状归纳特定的疾病，通过对住宅区的居民信息聚类来确定店铺的选址。</p><p>常用算法：K-Means算法、凝聚聚类算法、DBSCAN算法</p></li><li><p>异常检测</p><p>找出数据集中与正常数据差异较大的数据点（离群点或异常值）。</p><p>常用检测方法：统计方法检测、距离检测、密度检测、数据可视化检测和无监督模型检测。</p><p>聚类分析也是常见的用于异常检测的方法。</p><p>应用：识别诈骗、防范风险、发现新的营销热点。</p></li></ul><h1 id="可用的Python库"><a href="#可用的Python库" class="headerlink" title="可用的Python库"></a>可用的Python库</h1><p>Numpy - 科学计算库，主要用来做矩阵运算</p><p>Pandas - 数据分析处理库</p><p>Matplotlib - 可视化库</p><p>Seaborn  - 更简单的可视化库，封装在Matplot基础上</p><p>Scikit-learn - 机器学习库</p><h2 id="Scikit-learn-构建数据挖掘模型"><a href="#Scikit-learn-构建数据挖掘模型" class="headerlink" title="Scikit-learn 构建数据挖掘模型"></a>Scikit-learn 构建数据挖掘模型</h2><p>支持常用的机器学习算法——分类、回归、聚类与降维，提供了特征提取、数据处理和模型评估等功能模块。</p><p>Sklearn封装了大量的机器学习算法，并内置了大量数据集。</p><p>步骤：</p><p>数据获取→数据预处理→数据集拆分→构建模型→训练模型→评估模型→保存模型→使用模型</p><h3 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h3><p>4种常见的数据预处理方法：数据的归一化、数据的正则化、特征的二值化和One-hot编码转换。</p><h1 id="回归预测任务的参考框架"><a href="#回归预测任务的参考框架" class="headerlink" title="回归预测任务的参考框架"></a>回归预测任务的参考框架</h1><p>1、理解数据</p><p>​首先，了解数据的基本情况，包括各个属性的类型、缺失值情况、分布等。</p><p>2、数据清洗</p><p>​处理缺失值，可以选择删除、填充，或者根据其他属性进行预测填充。还需要处理其他可能存在的异常值或不一致性。</p><p>3、特征工程</p><p>​根据问题的要求和对数据的理解，选择合适的特征。可能需要对一些属性进行编码（如独热编码）、标准化或归一化，以便在建模过程中更好地处理。</p><p>4、数据分割</p><p>​将数据集分为训练集和测试集，训练集用于建模，测试集用于评估模型的性能。</p><p>5、选择模型</p><p>​选择适当的回归模型，常见的如线性回归、决策树回归、随机森林回归等。</p><p>6、模型训练：</p><p>​使用训练集对选择的模型进行训练。</p><p>7、模型评估</p><p>​使用测试集对选择的模型进行评估，考虑使用评价指标如均方误差等。</p><p>8、调整模型</p><p>​根据评估结果，可能需要调整模型的超参数或尝试其他模型。</p><h2 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h2><p>决定是否使用线性回归填充缺失值取决于数据的性质和关系。</p><p>1、线性关系</p><p>​线性回归假设目标变量与特征之间存在线性关系。通过绘制散点图或使用相关性系数等方法来初步判断。而且特征和残差之间的关系是平均的。</p><p>2、多重共线性</p><p>​如果特征之间存在多重共线性（即特征之间高度相关），线性回归的效果可能受到影响，这种情况下可能需要采取措施来处理共线性或者选择其他模型。</p><p>3、残差分析</p><p>​使用线性回归填充缺失值后，使用残差分析可以帮助评估模型的拟合情况。如果残差的分布显示模型的拟合效果不好，可能需要尝试其他模型。</p><hr><p>标称属性(nominal attribute)：代表某种类别、编码或者状态。比如头发颜色如黑色、棕色、黄色等。标称属性值不具有有意义的序且并不是定量的。众数是该属性的人中心趋势度量。均值和中位数都无意义。</p><h1 id="阅读清单"><a href="#阅读清单" class="headerlink" title="阅读清单"></a>阅读清单</h1><p>[1]<a href="https://www.zhihu.com/question/439511942">https://www.zhihu.com/question/439511942</a></p><p>[2]<a href="https://zhuanlan.zhihu.com/p/507174864">https://zhuanlan.zhihu.com/p/507174864</a></p><p>[3]<a href="https://primobe.uestc.edu.cn/primo-explore/search?query=any,contains,Ahmed%20Moustafa&tab=primo_central&search_scope=article_scope&vid=uestc&facet=topic,include,Computer%20Science&lang=zh_CN&offset=0">https://primobe.uestc.edu.cn/primo-explore/search?query=any,contains,Ahmed%20Moustafa&amp;tab=primo_central&amp;search_scope=article_scope&amp;vid=uestc&amp;facet=topic,include,Computer%20Science&amp;lang=zh_CN&amp;offset=0</a></p><p>[4]<a href="https://blog.csdn.net/wokaowokaowokao12345/article/details/109441753">https://blog.csdn.net/wokaowokaowokao12345/article/details/109441753</a></p><p>[5]<a href="https://cloud.tencent.com/developer/article/1654313">https://cloud.tencent.com/developer/article/1654313</a></p><p>[6]<a href="https://blog.csdn.net/qq_28168421/article/details/105190203">https://blog.csdn.net/qq_28168421/article/details/105190203</a></p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1]  王仁武 Python数据科学基础与实践</p>]]></content>
      
      
      <categories>
          
          <category> 数据挖掘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Data Science </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无线通信安全</title>
      <link href="/2023/10/20/%E6%97%A0%E7%BA%BF%E9%80%9A%E4%BF%A1%E5%AE%89%E5%85%A8/"/>
      <url>/2023/10/20/%E6%97%A0%E7%BA%BF%E9%80%9A%E4%BF%A1%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><span id="more"></span><h2 id="移动通信发展概述"><a href="#移动通信发展概述" class="headerlink" title="移动通信发展概述"></a>移动通信发展概述</h2><p><img src="/2023/10/20/%E6%97%A0%E7%BA%BF%E9%80%9A%E4%BF%A1%E5%AE%89%E5%85%A8/Users\86159\AppData\Roaming\Typora\typora-user-images\image-20231110153743131.png" alt="image-20231110153743131"></p><h2 id="5G应用场景与5G标准"><a href="#5G应用场景与5G标准" class="headerlink" title="5G应用场景与5G标准"></a>5G应用场景与5G标准</h2><p>定义的三大场景：</p><ul><li>eMBB 增强移动宽带  </li><li>mMTC 大规模物联网</li><li>URLLC 低时延高可靠连接</li></ul><p>频段：</p><p>eMBB 6GHz以下和6GHz以上频段</p><p>mMTC 6GHz以上频段</p><p>URLLC 6GHz以下频段</p><p>5G提供了一种 <u>广域覆盖、高速传输、强兼容性</u>的空地一体化信息通信网络，极大提升信息支援保障能力。</p><p>特点：</p><ul><li>大容量、大面积连续覆盖</li><li>机器间通信海量连接业务</li><li>低时延高可靠连接</li></ul><p>在特殊应用中需要满足不同的场景，比如实时远程传感器应用 —— 网络切片技术</p><blockquote><p>网络切片是一种按需组网的方式，可以让运营商在统一的基础设施上分离出多个虚拟的端到端网络，每个网络切片从无线接入网到承载网再到核心网上进行逻辑隔离，以适配各种各样类型的应用。</p></blockquote><p>大量无人系统等将接入网络</p><p>具体5G应用：</p><ul><li>智慧城市、智慧家庭&#x2F;建筑</li><li>3D&#x2F;超高清视频、增强现实</li><li>关键任务应用</li><li>工业自动化</li><li>自动驾驶</li><li>云端接入</li></ul><h3 id="5G标准"><a href="#5G标准" class="headerlink" title="5G标准"></a>5G标准</h3><p>3GPP中Rel-10&#x2F;11&#x2F;12. -&gt; LTE-Advanced 即4G+</p><p>Rel-13&#x2F;14 -&gt; LTE-A Pro 即4.5G</p><p>Rel-15 -&gt; eLTE</p><p>Rel-15定义5G标准的第一阶段，eLTE就意味着LTE向5G平滑演进。</p><p>R17正在进行中。</p><p><img src="/2023/10/20/%E6%97%A0%E7%BA%BF%E9%80%9A%E4%BF%A1%E5%AE%89%E5%85%A8/Users\86159\AppData\Roaming\Typora\typora-user-images\image-20231110160035557.png" alt="image-20231110160035557"></p><h2 id="安全通信的需求"><a href="#安全通信的需求" class="headerlink" title="安全通信的需求"></a>安全通信的需求</h2><ul><li>无线网络中被传输的信息加密很弱，容易被窃取、修改和插入</li><li>手机病毒利用微信信息、各种应用、普通短信、上网浏览、下载软<br>件与铃声等方式传播，还将攻击范围扩大到移动网关、WAP服务器<br>或其他的网络设备</li></ul><p>网络不安全的原因：自身缺陷+开放性+黑客攻击</p><p>数据安全：</p><ul><li>数据存储、处理加密技术</li><li>隐私保护技术</li><li>数据接入认证技术</li></ul><p>安全通信：</p><ul><li>数据传输加密技术</li><li>密钥管理、密钥分发技术</li><li>身份认证技术</li></ul><p>对无线通信网络的攻击：窃听、篡改、重放、干扰、欺诈</p><ul><li>无线接口：物理攻击、密码学攻击</li><li>无线设备：克隆、恶意软件注入</li><li>无线网络：对网络基础设施进行攻击，也包括内部人员破坏和泄密</li></ul><h2 id="手机接入和传输安全"><a href="#手机接入和传输安全" class="headerlink" title="手机接入和传输安全"></a>手机接入和传输安全</h2><p>加密 + 认证</p><p>空口传输安全</p><blockquote><p><strong>空口安全</strong> 由于空口是共享介质传输的，任何人都可以窃听或仿冒其他人的通信内容，或者向空口恶意发送大量数据，消耗空口带宽。 这类问题可以通过配置空口报文加密、接入认证、WIDS&#x2F;WIPS等解决。</p></blockquote><p>固网传输安全</p><p>数据安全</p><hr><p>无线通信物理联接缺失，更易于干扰，窃听避免、网络管理、安全接入的边界及方式相较有线网络方式更加难以控制。</p><img src="/2023/10/20/%E6%97%A0%E7%BA%BF%E9%80%9A%E4%BF%A1%E5%AE%89%E5%85%A8/blog\source\_posts\wireless_communication\wireless_net.png" alt="wireless_net"><p>用户的SIM卡和归宿网络的HLR&#x2F;AuC共享一个安全密钥Ki（64bits， 128bits），基于该密钥，网络可以对用户进行认证，但用户无法认证网络。</p><p>基站和手机间可以对无线链路进行加密。</p><p><strong>CA</strong>：</p><blockquote><p>Certificate Authority 证书颁发机构。即颁发数字证书的机构，是负责发放和管理数字证书的权威机构，并作为电子商务交易中受信任的第三方，承担公钥体系中公钥的合法性检验的责任。</p></blockquote><p><strong>AAA</strong>：</p><blockquote><p>AAA是Authentication(认证)、Authorization(授权)和Accounting(计费)的简称。</p><p>AAA服务器的功能：</p><ul><li>授予或拒绝对网络的访问</li><li>为用户提供不同级别的授权</li><li>记录所有建立网络连接的尝试</li></ul><p>AAA服务器是保障Wi-Fi安全的必备，它用每个用户或设备的唯一凭证取代了单一的预共享密钥（PSK）</p></blockquote><p><strong>网关</strong>：</p><blockquote><p>一个网络连接到另一个网络的接口，可以支持不同协议之间的转换，实现不同协议网络之间的互联。</p></blockquote><p><strong>GGSN</strong>：</p><blockquote><p>gateway GPRS Support Node</p><p>是GPRS网络中的关键部分，用于GPRS网络和外部分组交换网络（Internet, X.25, wimax)之间的交互。</p><p>从外部网络来看，GGSN就是一个子网的路由器，因为GGSN对外部网络隐藏了GPRS的底层结构。当GGSN接收到一个指定用户的数据时，检查用户是否是活动的。如果是，GGSN将数据转发给SGSN来服务用户，如果用户是不活动的，则丢弃数据包。反过来，GGSN将用户的数据包向外传递出去。</p></blockquote><p><img src="/2023/10/20/%E6%97%A0%E7%BA%BF%E9%80%9A%E4%BF%A1%E5%AE%89%E5%85%A8/Users\86159\AppData\Roaming\Typora\typora-user-images\image-20231110161208949.png" alt="image-20231110161208949"></p><p>3G网络：</p><ul><li>双向认证：网络可以对用户进行认证，用户也可以认证网络</li><li>接入网从服务地的核心网获得CK和IK。用它们作为密钥，终端和接入网之间可以实现简单的本地认证功能和进行加&#x2F;解密和保护。</li></ul><p><img src="/2023/10/20/%E6%97%A0%E7%BA%BF%E9%80%9A%E4%BF%A1%E5%AE%89%E5%85%A8/Users\86159\AppData\Roaming\Typora\typora-user-images\image-20231110161429278.png" alt="image-20231110161429278"></p><p>4G-LTE</p><blockquote><p>任何达到或超过100Mbps的无线数据网络系统都可以称作4G。4G技术是一种基于IP协议的宽带无线接入方式，其特点是数据传输速率高、延迟低、覆盖范围广、容量大及安全性高等。LTE是一种基于OFDM（正交频分复用）调制方式的无线通信技术。LTE技术是基于3GPP标准制定的，LTE一开始是3G的“加强版”，在技术上被称为3.9G，随着后期的发展LTE逐渐接近真正的4G。</p><p>LTE网络能够满足4G网络的标准（下行100Mbps），而4G时代又以LTE网络为主，所以通常将二者结合在一起，统称为4G LTE。</p></blockquote><p>采用加密措施（SNOW3G、AES、ZHU），采用AKA的认证协议，信息包传输采用加密，没有采用信息完整性认证</p><p>安全隐患：</p><ul><li>密钥长度越来越长但依然强度不足</li><li>序列号同步问题</li><li>IMSI标识的安全性</li><li>中间人攻击</li><li>恶意节点攻击</li></ul><h3 id="5G的安全需求"><a href="#5G的安全需求" class="headerlink" title="5G的安全需求"></a>5G的安全需求</h3><p><img src="/2023/10/20/%E6%97%A0%E7%BA%BF%E9%80%9A%E4%BF%A1%E5%AE%89%E5%85%A8/Users\86159\AppData\Roaming\Typora\typora-user-images\image-20231110161907529.png" alt="image-20231110161907529"></p><h3 id="网络架构"><a href="#网络架构" class="headerlink" title="网络架构"></a>网络架构</h3><p>移动站（MS）</p><ul><li><p>ME：移动设备</p></li><li><p>SIM：Subscriber Indentity Module 移动用户身份模块</p></li></ul><p>​• 存储移动用户的国际身份号IMSI（ International Mobile Equipment Identity）和<strong>认证密钥</strong>Ki</p><p>​• 实现移动用户身份认证功能，并生成<strong>加密密钥Kc</strong></p><p>基站子系统 BSS</p><ul><li>BTS：基站收发信机<ul><li>基带部分</li><li>控制部分</li><li>载频部分</li></ul></li><li>BSC：基站控制器</li></ul><p>​负责管理无线信道的分配，实现固定网路与移动用户之间的通信连接，传送系统信号和用户信息。</p><p>归属局（HLR）</p><blockquote><p>移动网的数据库，存放着由他控制的所有移动用户数据和移动用户的路由信号及状态信息</p></blockquote><p>认证中心（AC）</p><blockquote><p>AC中存放检查码的用户是否有权使用本网，它通过一组保密的鉴权参数和算法来鉴别用户的合法性</p></blockquote><p>拜访局（VLR)</p><blockquote><p>VLR保存着其控制区域内所有登记的移动用户信息，为以登记用户提供接续的条件</p></blockquote><p>设备号登记处（EIR）</p><blockquote><p>EIR中存放移动台的识别码，这个信息用于检查移动台是否合法，要否监视，应否关闭</p></blockquote><p>交换子系统（MSS）</p><p>​移动服务交换中心MSC</p><blockquote><p>​MSC是蜂房移动通信网的交换与控制中心，他除完成一般交换机的功能之外，还负责对移动系统的有线中继，天线信道的控制以及处理一些特殊功能，通过标准接口与基站子系统和其他NSS连接，并与公众电话网相连</p></blockquote><p>移动终端-基站子系统-网络管理-用户和终端设备数据库</p><p><img src="/2023/10/20/%E6%97%A0%E7%BA%BF%E9%80%9A%E4%BF%A1%E5%AE%89%E5%85%A8/Users\86159\AppData\Roaming\Typora\typora-user-images\image-20231110162856986.png" alt="image-20231110162856986"></p><hr><p>算法</p><ul><li>鉴权算法 A3 （产生的鉴权响应）</li><li>密钥生成算法 A8（产生密钥Kc）</li><li>加密算法 A5</li></ul><p>密钥</p><ul><li>Ki，用户主密钥</li><li>Kc，会话密钥</li></ul><p>识别号</p><ul><li>IMSI：国际移动用户标识号</li><li>TMSI：临时移动用户标识号</li><li>IMEI：国际移动设备身份码</li></ul><p>协议</p><ul><li>鉴权&#x2F;认证</li><li>匿名保护</li></ul><p>——</p><p>移动终端：A3 、A8、Ki、IMSI</p><p>基站子系统：A5</p><p>用户和终端设备数据库：A3、A8、Ki、IMSI</p><p>认证、会话密钥产生、加密</p><p><img src="/2023/10/20/%E6%97%A0%E7%BA%BF%E9%80%9A%E4%BF%A1%E5%AE%89%E5%85%A8/Users\86159\AppData\Roaming\Typora\typora-user-images\image-20231110163815379.png" alt="image-20231110163815379"></p><h3 id="算法详述"><a href="#算法详述" class="headerlink" title="算法详述"></a>算法详述</h3><p>A3和A8算法标准都使用COMP128加密算法，它是一个带密钥的散列函数</p><p><img src="/2023/10/20/%E6%97%A0%E7%BA%BF%E9%80%9A%E4%BF%A1%E5%AE%89%E5%85%A8/Users\86159\AppData\Roaming\Typora\typora-user-images\image-20231110164011185.png" alt="image-20231110164011185"></p><p>A5算法：流加密算法</p><p>​输入参数：64bit加密密钥 22bit帧序列号</p><p>​可以在硬件上高效实现</p><p>变种:A5&#x2F;1(较强版本)、A5&#x2F;2(较弱版本)、A5&#x2F;3(基于Kasumi)</p><p><img src="/2023/10/20/%E6%97%A0%E7%BA%BF%E9%80%9A%E4%BF%A1%E5%AE%89%E5%85%A8/Users\86159\AppData\Roaming\Typora\typora-user-images\image-20231110164100194.png" alt="image-20231110164100194"></p><p><img src="/2023/10/20/%E6%97%A0%E7%BA%BF%E9%80%9A%E4%BF%A1%E5%AE%89%E5%85%A8/Users\86159\AppData\Roaming\Typora\typora-user-images\image-20231110164323497.png" alt="image-20231110164323497"></p><h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><ol><li><p>A3&#x2F;A8算法缺陷（COMP128结构）</p><p>A5&#x2F;A8算法安全性：150000次尝试</p></li><li><p>SIM卡克隆（Ki，IMSI）</p><p>密钥易受攻击，IMSI是明文</p><p>利用读写器向SIM卡发送大量的假挑战，通过分析输入和输出数据之间的关系分析出Ki。</p></li><li><p>A5加密算法缺陷</p></li><li><p>非端到端加密</p><p>只在手机和基站间加密，核心网中明文传送</p></li><li><p>没有完整性检验</p><p>不能防篡改，中间人攻击</p></li><li><p>匿名性保护缺陷</p><p>移动台第一次注册和漫游时，仍需要明文发送IMSI<br>网络端可以要求用户发送IMSI以获得用户真实身份</p></li><li><p>单向认证（伪基站，中间人）</p><p><img src="/2023/10/20/%E6%97%A0%E7%BA%BF%E9%80%9A%E4%BF%A1%E5%AE%89%E5%85%A8/Users\86159\AppData\Roaming\Typora\typora-user-images\image-20231110164727322.png" alt="image-20231110164727322"></p><p>中间人攻击——一种接入身份认证攻击</p></li></ol><h2 id="3G-4G中的安全改进"><a href="#3G-4G中的安全改进" class="headerlink" title="3G&#x2F;4G中的安全改进"></a>3G&#x2F;4G中的安全改进</h2><p>1、使用更高强度的加密算法</p><p>​增加密钥长度至128位</p><p>2、消息完整性保护</p><p>​在消息上增加一个戳（Hash）函数，只有知道预分配密钥K的节点才能够产生这个戳。</p><p>3、双向认证</p><p>​采用和GSM系统相同的认证-响应协议，对用户进行认证。</p><p>​对网络的认证采用了基于序列号的方法，防止重传攻击。</p><p>4、增强的用户身份认证（匿名保护）</p><p>​不以明文传输IMSI &#x2F;TMSI,防止用户IMSI&#x2F;TMSI在无线信道上传输时被窃听。</p><p>序列号：Sequence Number (SQN)。用于移动终端认证网络。该序列号递增</p><p>，与用户身份一一对应。利用该序列号我们有可能判断出用户的身份。</p><h2 id="2G-3G-LTE安全机制比较"><a href="#2G-3G-LTE安全机制比较" class="headerlink" title="2G,3G,LTE安全机制比较"></a>2G,3G,LTE安全机制比较</h2><p><img src="/2023/10/20/%E6%97%A0%E7%BA%BF%E9%80%9A%E4%BF%A1%E5%AE%89%E5%85%A8/Users\86159\AppData\Roaming\Typora\typora-user-images\image-20231110170917683.png" alt="image-20231110170917683"></p><h2 id="2G和4G的比较"><a href="#2G和4G的比较" class="headerlink" title="2G和4G的比较"></a>2G和4G的比较</h2><p>• 2G单向认证，64比特密钥，加密的A5算法有缺陷，系统容易攻破</p><p>​A5算法是一种流mi</p><p>• 4G采用双向认证，128-256比特的密钥，采用AES、ZHU、或SHOW算法，系统强壮很多。</p><h2 id="SIM卡接入LTE网络"><a href="#SIM卡接入LTE网络" class="headerlink" title="SIM卡接入LTE网络"></a>SIM卡接入LTE网络</h2><p>LTE网络不允许接入SIM卡。</p><p>解决方案：</p><p><strong>HSS</strong>识别<strong>SIM</strong>卡或者<strong>USIM</strong>卡的时候，不排斥<strong>SIM</strong>卡，只要使用<strong>LTE</strong>终端装<strong>SIM</strong>卡，终端能够处理协助<strong>SIM</strong>卡解决<strong>LTE</strong>网络中的网络认证问题，<strong>SIM</strong>卡也可以接入<strong>LTE</strong>网络，密钥位数为<strong>64bit</strong>，可能安全性较低。</p><h2 id="七层模型与安全通信"><a href="#七层模型与安全通信" class="headerlink" title="七层模型与安全通信"></a>七层模型与安全通信</h2><p>常见的各层协议：</p><p>数据链路层：Ethernet（以太网）</p><p>网络层：IP，ARP,RARP,ICMP,IGMP</p><p>传输层：TCP,UDP</p><p>应用层：HTTP,Telnet,FTP,SMTP</p><p><img src="/2023/10/20/%E6%97%A0%E7%BA%BF%E9%80%9A%E4%BF%A1%E5%AE%89%E5%85%A8/Users\86159\AppData\Roaming\Typora\typora-user-images\image-20231110171735931.png" alt="image-20231110171735931"></p><h3 id="连接建立过程"><a href="#连接建立过程" class="headerlink" title="连接建立过程"></a>连接建立过程</h3><p>无线接入的过程：</p><p>1、扫描网络</p><p>2、选择网络</p><p>3、建立连接（通过无线路由器或基站获得网络访问权限）</p><p>4、获取IP地址：通过DHCP（动态主机配置协议）等方式</p><p>5、安全验证：在一些网络中可能需要进行安全验证，例如WPA（Wi-Fi保护访问）密码或其他身份验证方式</p><p>6、数据传输</p><h3 id="认证过程"><a href="#认证过程" class="headerlink" title="认证过程"></a>认证过程</h3><p>1、提供身份信息</p><p>2、传输身份信息</p><p>3、身份验证</p><p>4、授权访问</p><h3 id="TCP的三次握手"><a href="#TCP的三次握手" class="headerlink" title="TCP的三次握手"></a>TCP的三次握手</h3><p>1、SYN</p><p>2、SYN+ACK</p><p>3、ACK</p><h2 id="无线网络需要考虑的安全问题"><a href="#无线网络需要考虑的安全问题" class="headerlink" title="无线网络需要考虑的安全问题"></a>无线网络需要考虑的安全问题</h2><h2 id="5G新技术与安全威胁和安全保护资源"><a href="#5G新技术与安全威胁和安全保护资源" class="headerlink" title="5G新技术与安全威胁和安全保护资源"></a>5G新技术与安全威胁和安全保护资源</h2>]]></content>
      
      
      <categories>
          
          <category> 通信 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 通信安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>qrcode</title>
      <link href="/2023/10/16/qrcode/"/>
      <url>/2023/10/16/qrcode/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Python中有生成二维码的库，使用的最多的是qrcode</p><span id="more"></span><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>使用函数<br>    qrcode.make()<br>生成图像。<br>    .save(‘xx.jpg’)<br>函数保存生成的图像。</p><h2 id="设置二维码颜色大小参数"><a href="#设置二维码颜色大小参数" class="headerlink" title="设置二维码颜色大小参数"></a>设置二维码颜色大小参数</h2><p>首先创建QRcode对象<br>    qr &#x3D; qrcode.QRcode(version &#x3D; , error_correction&#x3D;qrcode.constants.ERROR_CORRECT_L, box_size&#x3D; , border&#x3D;)<br>参数设置：<br>version: 1-40 控制QR码的大小，实际上是二维码的格子矩阵大小  </p><blockquote><p>最小是21×21，最大是177×177。   </p></blockquote><p>error_correction: 二维码错误容许率，默认是M，容许小于15%的错误率</p><blockquote><p>L: 小于7%<br>Q: 小于25%<br>H: 小于30%  </p></blockquote><p>box_size: 每个小格子包含的像素数量，一般设为10<br>border: 二维码到图片边框的小格子数，默认值为4  </p><h2 id="实例化二维码生成类"><a href="#实例化二维码生成类" class="headerlink" title="实例化二维码生成类"></a>实例化二维码生成类</h2><pre><code>import qrcode  qr = qrcode.QRCode(version=1,error_correction=qrcode.constants.ERROR_CPRRECT_L,box_size=10,border=4,)  #设置数据  data = &quot;&quot;  qr.add_data(data=data)  #启用颜色设置qr.make(fit=True)  img = qr.make_image(fill_color=&quot;green&quot;,back_color=&quot;white&quot;)  #生成保存图片img.save(&#39;uestc.jpg&#39;)  #显示  img.show()</code></pre><h2 id="嵌入logo"><a href="#嵌入logo" class="headerlink" title="嵌入logo"></a>嵌入logo</h2><p>需要对要嵌入的图片进行处理，调整尺寸使其符合所需大小，然后通过paste方法将其粘贴到二维码的中心位置</p><pre><code>from PIL import Imageimport qrcode, osurl = &#39;电子科技大学&#39;qrcodename = &#39;logoqrcode&#39;#  def create_qrcode(url, qrcodename):qr=qrcode.QRCode (version=1, error_correction=qrcode.ERROR_CORRECT_H, box_size=8, border=1,)qr.add_data(url)qr.make(fit=True)img = qr.make_image()img = img.convert(&quot;RGBA&quot;) # 二维码设为彩色logo = Image.open(&#39;logo.png&#39;) # 传 gif 生成的二维码也是没有动态效果的w , h = img.sizelogo_w , logo_h = logo.sizefactor = 4 # 默认 logo 最大设为图片的四分之一s_w = int(w / factor)s_h = int(h / factor)if logo_w &gt; s_w or logo_h &gt; s_h:    logo_w = s_w    logo_h = s_hlogo = logo.resize((logo_w, logo_h), Image.ANTIALIAS)l_w = int((w - logo_w) / 2)l_h = int((h - logo_h) / 2)logo = logo.convert(&quot;RGBA&quot;)img.paste(logo, (l_w, l_h), logo)img.show()img.save(os.getcwd()+&#39;/&#39; + qrcodename + &#39;.png&#39;, quality=100)</code></pre><p>输出结果：   </p><p><img src="/2023/10/16/qrcode/qrcode.jpg">  </p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] 管小卫.基于Python 的二维码生成与识别[J].科学技术创新,2020,(25): 99-100</p>]]></content>
      
      
      <categories>
          
          <category> 物联网标识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> IoT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>insert_images</title>
      <link href="/2023/10/15/insert_images/"/>
      <url>/2023/10/15/insert_images/</url>
      
        <content type="html"><![CDATA[<p>插入图片测试</p><span id="more"></span><h1 id="不需要插件的本地引用"><a href="#不需要插件的本地引用" class="headerlink" title="不需要插件的本地引用"></a>不需要插件的本地引用</h1><pre><code>![](图片名.jpg)</code></pre><p><img src="/2023/10/15/insert_images/test.jpg"><br>在网页中成功显示但是不能预览</p><h1 id="hexo-asset-image"><a href="#hexo-asset-image" class="headerlink" title="hexo-asset-image"></a>hexo-asset-image</h1><pre><code>![](test.jpg)   </code></pre><p><img src="/2023/10/15/insert_images/test.jpg"><br>在网页中成功显示但是不能预览</p><pre><code>![](文件名/test.jpg)  </code></pre><p><img src="/insert_images/test.jpg"><br>成功预览但是在网页中显示失败<br>    <img src="/%E6%96%87%E4%BB%B6%E5%90%8D/test.jpg"> </p><p><img src="/insert_images/test.jpg"><br>成功预览但是在网页中显示失败</p><p>手动解析</p><pre><code>&lt;img src=&quot;/insert_images/test.jpg&quot; alt=&quot;&quot; /&gt;</code></pre><img src="/insert_images/test.jpg" alt>成功预览但是在网页中显示失败<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>使用如下形式插入：</p><pre><code>！[](图片名.jpg)  </code></pre><p>注意文件夹名字和图片名都不要使用中文</p>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息素养</title>
      <link href="/2023/10/14/%E4%BF%A1%E6%81%AF%E7%B4%A0%E5%85%BB/"/>
      <url>/2023/10/14/%E4%BF%A1%E6%81%AF%E7%B4%A0%E5%85%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="政府开放资源"><a href="#政府开放资源" class="headerlink" title="政府开放资源"></a>政府开放资源</h1><h2 id="思政与党史"><a href="#思政与党史" class="headerlink" title="思政与党史"></a>思政与党史</h2><p>习近平系列重要讲话数据库 <a href="http://jhsjk.people.cn/">http://jhsjk.people.cn/</a><br>新华社官网的学习进行时专栏 <a href="http://www.news.cn/politics/xxjxs/index.htm">http://www.news.cn/politics/xxjxs/index.htm</a><br>人民网官网的学习路上专栏学习路上 <a href="http://cpc.people.com.cn/xuexi/">http://cpc.people.com.cn/xuexi/</a><br>党史学习教育官方网站 <a href="http://dangshi.people.com.cn/">http://dangshi.people.com.cn/</a>   </p><span id="more"></span><h2 id="开放数据"><a href="#开放数据" class="headerlink" title="开放数据"></a>开放数据</h2><p>国家统计局网站的数据查询系统 <a href="https://data.stats.gov.cn/index.htm">https://data.stats.gov.cn/index.htm</a><br>世界银行的开放数据平台 <a href="https://data.worldbank.org/">https://data.worldbank.org/</a>   </p><h2 id="反诈骗"><a href="#反诈骗" class="headerlink" title="反诈骗"></a>反诈骗</h2><p>中国互联网联合辟谣平台 <a href="https://www.piyao.org.cn/">https://www.piyao.org.cn/</a><br>   辟谣信息查证栏目 <a href="https://www.piyao.org.cn/pysjk/frontsql.htm">https://www.piyao.org.cn/pysjk/frontsql.htm</a>   </p><h2 id="医卫"><a href="#医卫" class="headerlink" title="医卫"></a>医卫</h2><p>卫健委官网 <a href="http://www.nhc.gov.cn/">http://www.nhc.gov.cn/</a> 首页左侧服务栏目查询医卫信息<br>国家药品监督管理局 <a href="https://scc.zhixinst.com/detail?id=7a17da80-95e6-4a9d-b9be-b53ae92ec6d1">https://scc.zhixinst.com/detail?id=7a17da80-95e6-4a9d-b9be-b53ae92ec6d1</a></p><h2 id="文教"><a href="#文教" class="headerlink" title="文教"></a>文教</h2><p>学信网 <a href="https://www.chsi.com.cn/">https://www.chsi.com.cn/</a><br>查询毕业证书、学位证书<br>中国教育考试网 <a href="https://www.neea.edu.cn/">https://www.neea.edu.cn/</a><br>查询大学英语四六级考试、全国计算机等级考试、教师资格证这三类考试的成绩和资格证书信息  </p><h2 id="法律"><a href="#法律" class="headerlink" title="法律"></a>法律</h2><p>国家法律法规数据库 <a href="https://flk.npc.gov.cn/">https://flk.npc.gov.cn/</a><br>查询我国各层级法律法规<br>中国裁判文书网 <a href="https://wenshu.court.gov.cn/">https://wenshu.court.gov.cn/</a><br>查询公开的判决书<br>中国执行信息网 <a href="http://zxgk.court.gov.cn/">http://zxgk.court.gov.cn/</a><br>查询被执行人、失信被执行人、限制消费人员<br>最高人民法院知识产权法庭网 <a href="https://ipc.court.gov.cn/zh-cn/index.html">https://ipc.court.gov.cn/zh-cn/index.html</a><br>查询知识产权相关诉讼的民事裁定书等  </p><h2 id="标准及标准文献"><a href="#标准及标准文献" class="headerlink" title="标准及标准文献"></a>标准及标准文献</h2><blockquote><p>标准文献是指由技术标准管理标准经济标准及其他具有标准性质的类似文件所组成的一种特种文献。<br>标准号是国际标准、国家标准、行业标准、企业标准等标准的编号，基本结构为：标准代号+专业类号+顺序号+年代号。标准编号有国际标准编号和中国的国家标准编号两种。  </p></blockquote><p>国家标准全文公开系统 <a href="https://openstd.samr.gov.cn/bzgk/gb/">https://openstd.samr.gov.cn/bzgk/gb/</a><br>全国标准信息公共服务平台 <a href="https://std.samr.gov.cn/gb">https://std.samr.gov.cn/gb</a><br>国家部委官方网站 <a href="https://www.mohurd.gov.cn/">https://www.mohurd.gov.cn/</a><br>国家卫生健康委员会 <a href="http://www.nhc.gov.cn/">http://www.nhc.gov.cn/</a>  </p><h2 id="专利及专利文献"><a href="#专利及专利文献" class="headerlink" title="专利及专利文献"></a>专利及专利文献</h2><blockquote><p>专利文献有统一的编排体例，采用国际统一的专利文献著录项目识别代码(INID 码)，专利说明书有法定的文体结构，从发明创造名称、所涉及的技术领域和背景技术到发明内容、附图说明和具体实施方式等，每项内容都有具体的撰写要求和固定的顺序，并严格限定已有技术与发明内容之间的界线。    </p></blockquote><blockquote><p>专利文献是包含已经申请或被确认为发现、发明、实用新型和工业品外观设计的研究、设计、开发和试验成果的有关资料，以及保护发明人、专利所有人及工业品外观设计和实用新型注册证书持有人权利的有关资料的已出版或未出版的文件（或其摘要）的总称。</p></blockquote><p>国家知识产权局的“专利公布公告”系统 <a href="http://epub.cnipa.gov.cn/">http://epub.cnipa.gov.cn/</a><br>“专利检索及分析”系统 <a href="https://pss-system.cponline.cnipa.gov.cn/conventionalSearch">https://pss-system.cponline.cnipa.gov.cn/conventionalSearch</a><br>国家知识产权局 <a href="https://www.cnipa.gov.cn/">https://www.cnipa.gov.cn/</a><br>地理标志和官方标志公告 <a href="https://www.cnipa.gov.cn/col/col2089/index.html">https://www.cnipa.gov.cn/col/col2089/index.html</a><br>美国专利商标局的专利检索系统PPUBS <a href="https://ppubs.uspto.gov/pubwebapp/static/pages/landing.html">https://ppubs.uspto.gov/pubwebapp/static/pages/landing.html</a><br>欧盟专利局的espacenet <a href="https://ie.espacenet.com/">https://ie.espacenet.com/</a></p><h2 id="商标及商标数据"><a href="#商标及商标数据" class="headerlink" title="商标及商标数据"></a>商标及商标数据</h2><p>国家知识产权局商标局 <a href="https://sbj.cnipa.gov.cn/sbj/index.html">https://sbj.cnipa.gov.cn/sbj/index.html</a><br>“商标查询系统” <a href="https://sbj.cnipa.gov.cn/sbj/sbcx/">https://sbj.cnipa.gov.cn/sbj/sbcx/</a></p><h1 id="实用学习资源"><a href="#实用学习资源" class="headerlink" title="实用学习资源"></a>实用学习资源</h1><h2 id="MOOC"><a href="#MOOC" class="headerlink" title="MOOC"></a>MOOC</h2><p>中国大学MOOC <a href="https://www.icourse163.org/">https://www.icourse163.org/</a><br>学堂在线 <a href="https://www.xuetangx.com/">https://www.xuetangx.com/</a><br>智慧树 zhihuishu.com<br>学银在线 <a href="https://www.xueyinonline.com/">https://www.xueyinonline.com/</a><br>EDX网站 <a href="https://www.edx.org/">https://www.edx.org/</a><br>国家高等教育智慧教育平台（<a href="https://higher.smartedu.cn/">https://higher.smartedu.cn/</a><br>国家职业教育智慧教育平台（<a href="https://vocational.smartedu.cn/%EF%BC%89">https://vocational.smartedu.cn/）</a><br>国家虚拟仿真实验教学课程共享平台（<a href="http://www.ilab-x.com)/">http://www.ilab-x.com）</a>  </p><h2 id="实用视频"><a href="#实用视频" class="headerlink" title="实用视频"></a>实用视频</h2><p>网易公开课（<a href="https://open.163.com)/">https://open.163.com）</a><br>一席（<a href="https://www.yixi.tv)/">https://www.yixi.tv）</a></p><h2 id="免费电子书"><a href="#免费电子书" class="headerlink" title="免费电子书"></a>免费电子书</h2><p>HathiTrust（<a href="https://www.hathitrust.org)/">https://www.hathitrust.org）</a><br>牛津学术数据库（<a href="https://academic.oup.com)/">https://academic.oup.com）</a> </p><h2 id="国家图书馆免费数字资源"><a href="#国家图书馆免费数字资源" class="headerlink" title="国家图书馆免费数字资源"></a>国家图书馆免费数字资源</h2><p>国家图书馆（<a href="http://www.nlc.cn)/">http://www.nlc.cn）</a><br>国家图书馆旗下的中华古籍资源库（<a href="http://read.nlc.cn/thematDataSearch/toGujiIndex%EF%BC%89">http://read.nlc.cn/thematDataSearch/toGujiIndex）</a><br>民国时期文献库（<a href="http://read.nlc.cn/specialResourse/minguoIndex%EF%BC%89">http://read.nlc.cn/specialResourse/minguoIndex）</a></p><h2 id="美国国会图书馆免费数字资源"><a href="#美国国会图书馆免费数字资源" class="headerlink" title="美国国会图书馆免费数字资源"></a>美国国会图书馆免费数字资源</h2><p>美国国会图书馆网站（<a href="https://www.loc.gov)/">https://www.loc.gov）</a></p><h2 id="问答社区信息资源"><a href="#问答社区信息资源" class="headerlink" title="问答社区信息资源"></a>问答社区信息资源</h2><p>知乎</p><p>美国哈佛大学的馆藏查询系统 HOLLIS</p>]]></content>
      
      
      <categories>
          
          <category> 比赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息检索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>雅思考试学习网站</title>
      <link href="/2023/10/13/%E9%9B%85%E6%80%9D%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%AB%99/"/>
      <url>/2023/10/13/%E9%9B%85%E6%80%9D%E8%80%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>过了雅思考试后为了整理收藏夹所以把收藏过的雅思网站列出来，虽然以后可能也用不到了但是不忍心就这么删掉です。</p><span id="more"></span><h1 id="口语"><a href="#口语" class="headerlink" title="口语"></a>口语</h1><ul><li><p>SpeechAce<br><a href="https://app.speechace.co/placement/">https://app.speechace.co/placement/</a><br>适合单个单词的发音自纠，自己说和听标准音频很难意识到发音的错误点</p></li><li><p>新东方雅思|雅思口语练习<br><a href="https://ieltscat.xdf.cn/practice/speak">https://ieltscat.xdf.cn/practice/speak</a><br>真题题库练习，参考答案不太走寻常路（，还是可以拓展观点库的</p></li><li><p>Take IELTS<br><a href="https://takeielts.britishcouncil.org/take-ielts/prepare/free-ielts-practice-tests/speaking">https://takeielts.britishcouncil.org/take-ielts/prepare/free-ielts-practice-tests/speaking</a><br>全英的学习指导，毕竟是英语语境，是有一定学习意义的   </p></li><li><p>IELTS CUE CARD<br><a href="https://www.ieltscuecard.com/">https://www.ieltscuecard.com/</a><br>也是全英的雅思口语答案范例，我没有怎么看过所以不好评价  </p></li><li><p>bilibili<br>多刷刷雅思相关的就会给你推送很多题库的视频，考前看了一个tea相关的视频而且记住了，刚好就考了，所以碎片化的视频也可以发挥作用的<br>推荐Lina老师的口语课程，讲得很好<br><a href="https://www.bilibili.com/video/BV1wF411a76V/?share_source=copy_web&vd_source=f7a2fbf107b2f506f23176d635b31c85">https://www.bilibili.com/video/BV1wF411a76V/?share_source=copy_web&amp;vd_source=f7a2fbf107b2f506f23176d635b31c85</a></p></li></ul><h2 id="当季题库的练习"><a href="#当季题库的练习" class="headerlink" title="当季题库的练习"></a>当季题库的练习</h2><p>建议用手机app，小站雅思、雅思哥等大多流行的雅思app都可，虽然新东方的用起来不怎么样（<br>再推荐一个app：快练英语，可以自由练习也可以完整练习雅思口语考试，并且会针对回答个性化批改，最重要的是free(<br>口语极烂的我靠着题库和这个app幸运过6（躺</p><h1 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h1><ul><li>老烤鸭<br><a href="http://www.laokaoya.com/ieltsvip/">http://www.laokaoya.com/ieltsvip/</a><br>非常适合阅读和听力的纠错（自己是真的搞不懂为什么错了的时候</li></ul><h1 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h1><ul><li><p>微软爱写作<br><a href="https://aimwriting.mtutor.engkoo.com/">https://aimwriting.mtutor.engkoo.com/</a><br>虽然用久了就会发现纠错其实挺逆天的但是也不是毫无可取之处，比如同义词替换功能<br>每次都是八分的评分令人信心爆棚！（不是</p></li><li><p>QuillBot<br><a href="https://quillbot.com/grammar-check">https://quillbot.com/grammar-check</a><br>这个的语法检查功能（Grammar Checker）就明显比上一个好。但是果然AI还是无论如何都替代不了真人老师的（但是要是能买得起批改谁会用AI捏（<br>总之也不是不能用，能提供一定的纠错，再加上自我反思就好了   </p></li><li><p>微信公众号<br>真的能搜到很多很好的文章，而且因为资源很多也可以选择自己喜欢的或者适合自己的学习</p></li></ul><h1 id="综合"><a href="#综合" class="headerlink" title="综合"></a>综合</h1><ul><li><p>IELS Liz<br><a href="https://ieltsliz.com/">https://ieltsliz.com/</a><br>全英的免费雅思学习网站，虽然也没怎么用过但是看着是挺好的</p></li><li><p>上面提到的老烤鸭也是全方面的信息都有提供</p></li></ul><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>其实我的雅思学习过程算挺短的，没有完整的流程或者学习链，也没有深入地学习某一个网站或者教程的内容，但是不可否认特别是口语和作文，确实是要花心思去找资料和认真积累和思考的。祝你也能通过你的IELTS考试~</p>]]></content>
      
      
      <categories>
          
          <category> 语言学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IELTS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ChiMerge</title>
      <link href="/2023/10/09/ChiMerge/"/>
      <url>/2023/10/09/ChiMerge/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>ChiMerge是一种监督的、自底向上的数据离散化方法，依赖于卡方分析。</p><h1 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>初始化过程分为排序和初始离散化。<br>首先根据训练样本对被离散属性的值进行排序，在每个样本前后放置一个区间边界。</p><span id="more"></span><h2 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h2><p>将具有最小卡方值的相邻区间合并在一起，直到满足确定的停止标准。<br><strong>卡方值的计算公式：</strong><br><img src="/2023/10/09/ChiMerge/tst.png"><br>$ \sum_{1}^{m}\sum_{1}^{k}\frac{(Aij-Eij)^2}{Eij} $<br>m&#x3D;2（比较的两个区间）<br>k为种类数<br>Aij为第i个区间，第j个种类的样本数<br>Ri为第i个区间内的样本数<br>Cj为第j个种类内的样本数<br>N为总样本数<br>Eij为Aij的期望频率，计算公式为Ri*Cj&#x2F;N</p><h2 id="分裂点"><a href="#分裂点" class="headerlink" title="分裂点"></a>分裂点</h2><p>分裂点是划分区间的点。</p><h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2><p>示例：<br><code>5.1,3.5,1.4,0.2,Iris-setosa</code><br>分别代表：花萼长度(sepal-length)、花萼宽度(sepal-width)、花瓣长度(petal-length)、花瓣宽度(petal-width)、类别</p><h2 id="输入数据处理"><a href="#输入数据处理" class="headerlink" title="输入数据处理"></a>输入数据处理</h2><p>输入的类别使用的是字符串，所以先将对类别编码以便后续处理。<br>使用<code>strcmp()</code>进行处理，该函数是C语言中的字符串比较函数，如果返回值为0则表示两字符串相等。<br>数据中有四种类型的数据，所以需要计算四次。因此将ChiMerge写成函数调用比较方便。   </p><h2 id="ChiMerge-A"><a href="#ChiMerge-A" class="headerlink" title="ChiMerge(A)"></a>ChiMerge(A)</h2><p>为了计算卡方值，需要先计算期望频数（类别样本数*区间样本数&#x2F;总样本数）<br>需要注意，在计算期望频数时，如果某个期望频数为0，会导致计算卡方值时分母为0，将会引起错误。所以当期望频数为0时，应该改为一个较小的非零值以保证计算的稳定性。</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><pre><code>function main[a,b,c,d,class] = textread(&#39;iris.txt&#39;,&#39;%f,%f,%f,%f,%s&#39;);%花萼长度，花萼宽度，花瓣长度，花瓣宽度，类别num = size(class);for i = 1:num(1)    if strcmp(class(i),&#39;Iris-setosa&#39;)==1        cls(i,1)=1;    elseif strcmp(class(i),&#39;Iris-versicolor&#39;)==1        cls(i,1)=2;    elseif strcmp(class(i),&#39;Iris-virginica&#39;)==1         cls(i,1)=3;    endendA = [a cls];B = [b cls];C = [c cls];D = [d cls];disp(&#39;sepal-length:&#39;);chimerge(A);disp(&#39;sepal-width:&#39;);chimerge(B);disp(&#39;petal-length:&#39;);chimerge(C);disp(&#39;petal-width:&#39;);chimerge(D);function X = chimerge(A)% X矩阵的第一、二行代表两个待合并区间中各个类别的频数，第三行代表每个区间中各个类别的的样本总数，第一列到第三列代表各个类别的频数，第四列到第六列代表各个类别的期望频数，第七列代表每个区间的样本总数y = sortrows(A,1);%按属性值排序ys = size(y);ylen = ys(1);%属性值个数x = [y(:,1),y(:,1)];%初始化区间矩阵，初始值设置为y的第一列属性值xs = size(x);xlen = xs(1);%区间个数while xlen &gt; 6 %停止条件为最大区间数为6    min = 999999;%保存最小卡方值，初始化为一个较大的值    for j = 1:xlen-1        ans = 0;        X = zeros(3,7);        %对于每个区间，统计在该区间内属于每个类别的样本数，存储在X矩阵中        for i = 1:ylen            if y(i,1)&gt;=x(j,1)&amp;&amp;y(i,1)&lt;=x(j,2)                X(1,y(i,2))=X(1,y(i,2))+1;            elseif y(i,1)&gt;=x(j+1,1)&amp;&amp;y(i,1)&lt;=x(j+1,2)                X(2,y(i,2))=X(2,y(i,2))+1;            end        end        %计算每个类别的样本个数        for i = 1:3            X(3,i) = X(1,i)+X(2,i);        end        %计算每个区间的样本个数，存储在X的第七列中        for i =1:3            X(i,7) = X(i,1)+X(i,2)+X(i,3);        end        %计算期望频数        for i = 1:2 %两个待合并区间            for k = 4:6 %每个类别的期望频数                X(i,k) = X(i,7)*X(3,k-3)/X(3,7);                if X(i,k) == 0%避免零分母的情况                    X(i,k) = 0.1;                end            end        end    %计算卡方值    for i = 1:2        for k = 1:3            ans = ans + ((X(i,k)-X(i,k+3))^2)/X(i,k+3);        end    end    if ans &lt;= min        min = ans;        key = j;%记录最小卡方值的区间    end    end    %合并区间，删除合并过的后一个区间    x(key,2) = x(key+1,2);    x(key+1,:) = [];    xlen = xlen-1;%更新区间数endx</code></pre><h2 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h2><pre><code>&gt;&gt; ChiMerge</code></pre><p>sepal-length:</p><p>x &#x3D;</p><pre><code>4.3000    4.80004.9000    4.90005.0000    5.40005.5000    5.70005.8000    7.00007.1000    7.9000</code></pre><p>sepal-width:</p><p>x &#x3D;</p><pre><code>2.0000    2.20002.3000    2.40002.5000    2.80002.9000    2.90003.0000    3.30003.4000    4.4000</code></pre><p>petal-length:</p><p>x &#x3D;</p><pre><code>1.0000    1.90003.0000    4.40004.5000    4.70004.8000    4.90005.0000    5.10005.2000    6.9000</code></pre><p>petal-width:</p><p>x &#x3D;</p><pre><code>0.1000    0.60001.0000    1.30001.4000    1.60001.7000    1.70001.8000    1.80001.9000    2.5000</code></pre><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>离散化是一种很重要的处理，因为很多分类算法都需要离散的训练数据。ChiMerge是一种通用且具有鲁棒性的离散化算法。<br>ChiMerge算法根据卡方检验进行分箱，将连续的值划分为多个区间来实现离散化。</p><blockquote><p>为什么采用卡方检验？    </p></blockquote><p>卡方检验确定的是观察到的频数与预期频数之间的偏离程度，最小卡方值确定的也就是最相似的分区。采用这样的方式能够有效地减少离散化过程中的信息损失，保留原始数据的特征</p><blockquote><p>评估ChiMerge算法的一些手段</p></blockquote><ol><li>可视化分析<br>观察离散化后的属性值分布情况，如果离散化合理，不同区间内的数据应该有显著的差异性。</li><li>信息增益<br>计算离散化后的属性对目标变量的信息增益。通过比较原始连续属性和离散化后的属性的信息增益，可以判断ChiMerge算法是否能够保留原始数据的重要信息。</li><li>卡方统计量<br>计算离散化后相邻区间的卡方值，检验它们之间的差异是否具有统计值意义。如果卡方值显著高于预期阈值，说明离散化后的区间差异明显。</li><li>分类或回归模型评估<br>使用离散化后的属性作为输入，训练分类或回归模型，比较模型在原始连续属性和离散化后的属性上的性能指标（如准确率、精确度等）。</li></ol><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] Randy Kerber, “ChiMerge: Discretization of Numeric Attributes”, AAAI, p.123, 1992.<br>[2] <a href="https://developer.aliyun.com/article/632385">https://developer.aliyun.com/article/632385</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据挖掘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 离散化算法 </tag>
            
            <tag> matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇博客</title>
      <link href="/2023/10/09/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/2023/10/09/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>本文为测试第一篇博客的发布<br>先挖个美化主页的坑（</p>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文章创建 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
